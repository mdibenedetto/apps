{
  "id": "low-level-design",
  "title": "Low Level Design (LLD)",
  "description": "Object-oriented design principles and patterns",
  "icon": "Code2",
  "color": "low-level-design",
  "introduction": "Low Level Design focuses on how to implement a system using object-oriented principles and design patterns. While High Level Design deals with architecture and scalability, LLD deals with class diagrams, design patterns, and SOLID principles. This section covers OOP concepts, design principles, UML, and the most common design patterns asked in interviews.",
  "topics": [
    {
      "id": "what-is-lld",
      "title": "What is Low Level Design?",
      "description": "Understanding LLD vs HLD",
      "content": [
        "Low Level Design (LLD) translates High Level Design into detailed component specifications.",
        "",
        "## HLD vs LLD",
        "",
        "**High Level Design**:",
        "- System architecture",
        "- Component interactions",
        "- Scalability, availability",
        "- Technology choices",
        "- Example: Microservices with load balancers, databases, caches",
        "",
        "**Low Level Design**:",
        "- Class diagrams",
        "- Data structures and algorithms",
        "- Design patterns",
        "- Method signatures",
        "- Example: Observer pattern for notifications, Strategy pattern for payment methods",
        "",
        "## LLD Interview Focus",
        "",
        "**Common Questions**:",
        "- Design a parking lot",
        "- Design an elevator system",
        "- Design a chess game",
        "- Design a library management system",
        "",
        "**What Interviewers Look For**:",
        "1. **OOP Principles**: Proper use of encapsulation, inheritance, polymorphism",
        "2. **Design Patterns**: Recognizing when to apply Factory, Strategy, Observer, etc.",
        "3. **SOLID Principles**: Code that's maintainable and extensible",
        "4. **Trade-offs**: Discussing pros/cons of design choices"
      ],
      "keyPoints": [
        "HLD = Architecture, LLD = Code Design",
        "Focus on classes, interfaces, relationships",
        "Apply SOLID principles and design patterns",
        "Draw UML diagrams to communicate design"
      ]
    },
    {
      "id": "oop-concepts",
      "title": "Object-Oriented Programming (OOP)",
      "description": "Four pillars of OOP",
      "content": [
        "OOP organizes code around objects that encapsulate data and behavior.",
        "",
        "## Four Pillars",
        "",
        "### 1. Encapsulation",
        "Bundle data and methods that operate on that data.",
        "**Benefits**: Data hiding, modularity, easier maintenance",
        "",
        "```typescript",
        "class BankAccount {",
        "  private balance: number = 0;  // private data",
        "  ",
        "  deposit(amount: number) {     // public method",
        "    this.balance += amount;",
        "  }",
        "  ",
        "  getBalance(): number {         // controlled access",
        "    return this.balance;",
        "  }",
        "}",
        "```",
        "",
        "### 2. Inheritance",
        "Create new classes from existing ones.",
        "**Benefits**: Code reuse, hierarchical classification",
        "",
        "```typescript",
        "class Animal {",
        "  move() { console.log('Moving'); }",
        "}",
        "",
        "class Dog extends Animal {",
        "  bark() { console.log('Woof!'); }",
        "}",
        "```",
        "",
        "### 3. Polymorphism",
        "Objects of different types respond to the same method call.",
        "**Types**: Method overriding (runtime), Method overloading (compile-time)",
        "",
        "```typescript",
        "class Shape {",
        "  area(): number { return 0; }",
        "}",
        "",
        "class Circle extends Shape {",
        "  constructor(private radius: number) { super(); }",
        "  area(): number { return Math.PI * this.radius ** 2; }",
        "}",
        "",
        "class Rectangle extends Shape {",
        "  constructor(private width: number, private height: number) { super(); }",
        "  area(): number { return this.width * this.height; }",
        "}",
        "```",
        "",
        "### 4. Abstraction",
        "Hide complex implementation details, expose only essentials.",
        "**Tools**: Abstract classes, interfaces",
        "",
        "```typescript",
        "interface PaymentMethod {",
        "  pay(amount: number): void;",
        "}",
        "",
        "class CreditCard implements PaymentMethod {",
        "  pay(amount: number) { /* Stripe API call */ }",
        "}",
        "",
        "class PayPal implements PaymentMethod {",
        "  pay(amount: number) { /* PayPal API call */ }",
        "}",
        "```"
      ],
      "keyPoints": [
        "Encapsulation = Data hiding with access modifiers",
        "Inheritance = IS-A relationship",
        "Polymorphism = Many forms, same interface",
        "Abstraction = Hide complexity, show essentials"
      ]
    },
    {
      "id": "solid-principles",
      "title": "SOLID Principles",
      "description": "Five principles for maintainable OOP code",
      "content": [
        "SOLID is an acronym for five design principles that make software more understandable, flexible, and maintainable.",
        "",
        "## S - Single Responsibility Principle (SRP)",
        "**A class should have only one reason to change.**",
        "",
        "❌ **Bad**: Class doing multiple things",
        "```typescript",
        "class User {",
        "  saveToDatabase() { /* DB logic */ }",
        "  sendEmail() { /* Email logic */ }",
        "  generateReport() { /* Report logic */ }",
        "}",
        "```",
        "",
        "✅ **Good**: Separate responsibilities",
        "```typescript",
        "class User { /* User data */ }",
        "class UserRepository { saveToDatabase() {} }",
        "class EmailService { sendEmail() {} }",
        "class ReportGenerator { generateReport() {} }",
        "```",
        "",
        "## O - Open/Closed Principle (OCP)",
        "**Open for extension, closed for modification.**",
        "",
        "Use abstraction to add new behavior without changing existing code.",
        "",
        "```typescript",
        "interface Shape { area(): number; }",
        "",
        "class Circle implements Shape { area() { return Math.PI * r * r; } }",
        "class Square implements Shape { area() { return side * side; } }",
        "",
        "function calculateTotalArea(shapes: Shape[]) {",
        "  return shapes.reduce((sum, shape) => sum + shape.area(), 0);",
        "}",
        "```",
        "",
        "## L - Liskov Substitution Principle (LSP)",
        "**Subtypes must be substitutable for their base types.**",
        "",
        "❌ **Bad**: Square extends Rectangle violates LSP",
        "```typescript",
        "class Rectangle {",
        "  setWidth(w) { this.width = w; }",
        "  setHeight(h) { this.height = h; }",
        "}",
        "",
        "class Square extends Rectangle {",
        "  setWidth(w) { this.width = this.height = w; } // Breaks expectation",
        "}",
        "```",
        "",
        "✅ **Good**: Use composition or separate hierarchy",
        "",
        "## I - Interface Segregation Principle (ISP)",
        "**Clients shouldn't depend on interfaces they don't use.**",
        "",
        "❌ **Bad**: Fat interface",
        "```typescript",
        "interface Worker {",
        "  work(): void;",
        "  eat(): void;",
        "}",
        "",
        "class Robot implements Worker {",
        "  work() { /* OK */ }",
        "  eat() { /* Robots don't eat! */ }",
        "}",
        "```",
        "",
        "✅ **Good**: Split interfaces",
        "```typescript",
        "interface Workable { work(): void; }",
        "interface Eatable { eat(): void; }",
        "",
        "class Human implements Workable, Eatable { /* Both */ }",
        "class Robot implements Workable { /* Only work */ }",
        "```",
        "",
        "## D - Dependency Inversion Principle (DIP)",
        "**Depend on abstractions, not concretions.**",
        "",
        "❌ **Bad**: High-level depends on low-level",
        "```typescript",
        "class MySQLDatabase { connect() {} }",
        "",
        "class UserService {",
        "  private db = new MySQLDatabase(); // Tightly coupled",
        "}",
        "```",
        "",
        "✅ **Good**: Depend on interface",
        "```typescript",
        "interface Database { connect(): void; }",
        "",
        "class UserService {",
        "  constructor(private db: Database) {} // Dependency injection",
        "}",
        "```"
      ],
      "keyPoints": [
        "SRP: One class, one responsibility",
        "OCP: Extend behavior without modification",
        "LSP: Subtypes must work where base types work",
        "ISP: Small, specific interfaces",
        "DIP: Depend on abstractions, inject dependencies"
      ]
    },
    {
      "id": "design-principles",
      "title": "Other Design Principles",
      "description": "DRY, KISS, YAGNI",
      "content": [
        "Beyond SOLID, these principles guide clean code design.",
        "",
        "## DRY - Don't Repeat Yourself",
        "**Every piece of knowledge should have a single source of truth.**",
        "",
        "❌ **Bad**: Duplicated logic",
        "```typescript",
        "function calculateDiscountForUser(price) {",
        "  return price * 0.9; // 10% discount",
        "}",
        "",
        "function calculateDiscountFor VIP(price) {",
        "  return price * 0.9; // Same logic duplicated",
        "}",
        "```",
        "",
        "✅ **Good**: Extract common logic",
        "```typescript",
        "function applyDiscount(price, discountRate) {",
        "  return price * (1 - discountRate);",
        "}",
        "",
        "const userDiscount = applyDiscount(price, 0.1);",
        "const vipDiscount = applyDiscount(price, 0.1);",
        "```",
        "",
        "## KISS - Keep It Simple, Stupid",
        "**Simplicity should be a key goal. Avoid unnecessary complexity.**",
        "",
        "❌ **Bad**: Over-engineered",
        "```typescript",
        "class AbstractFactoryPatternSingletonBuilderAdapter {",
        "  // 500 lines of abstraction for a simple task",
        "}",
        "```",
        "",
        "✅ **Good**: Simple solution",
        "```typescript",
        "function getUserById(id: string): User {",
        "  return users.find(u => u.id === id);",
        "}",
        "```",
        "",
        "**When to apply**: Unless you have clear future requirements, choose the simplest solution that works.",
        "",
        "## YAGNI - You Aren't Gonna Need It",
        "**Don't add functionality until it's necessary.**",
        "",
        "❌ **Bad**: Premature optimization",
        "```typescript",
        "class User {",
        "  // Adding 20 fields we 'might' need later",
        "  futureFeature1?: string;",
        "  futureFeature2?: number;",
        "  // ...",
        "}",
        "```",
        "",
        "✅ **Good**: Add only what's needed now",
        "```typescript",
        "class User {",
        "  id: string;",
        "  name: string;",
        "  email: string;",
        "  // Add more fields when actually needed",
        "}",
        "```",
        "",
        "**Balance**: Don't over-design for hypothetical futures, but don't paint yourself into a corner."
      ],
      "keyPoints": [
        "DRY: Extract reusable logic, avoid duplication",
        "KISS: Simple solutions are easier to maintain",
        "YAGNI: Don't build features you don't need yet",
        "Balance simplicity with extensibility"
      ]
    },
    {
      "id": "uml",
      "title": "Unified Modeling Language (UML)",
      "description": "Visual notation for system design",
      "content": [
        "UML provides standardized diagrams to visualize object-oriented designs. Master these diagrams for technical interviews and design discussions.",
        "",
        "## Class Diagrams",
        "Show classes, attributes, methods, and relationships.",
        "",
        "### Components",
        "",
        "**Class Box** (3 sections):",
        "```",
        "┌──────────────────┐",
        "│   ClassName      │  ← Class Name",
        "├──────────────────┤",
        "│ - privateField   │  ← Attributes (-private, +public, #protected)",
        "│ + publicField    │",
        "├──────────────────┤",
        "│ + method()       │  ← Methods",
        "│ - privateMethod()│",
        "└──────────────────┘",
        "```",
        "",
        "### Relationships",
        "",
        "**1. Association** (solid line): \"has-a\" relationship",
        "```",
        "Student ────────── Course",
        "        enrolls in",
        "```",
        "",
        "**2. Aggregation** (hollow diamond): Weak \"has-a\" (can exist independently)",
        "```",
        "Department ◇────── Professor",
        "           has",
        "```",
        "Professor can exist without Department.",
        "",
        "**3. Composition** (filled diamond): Strong \"has-a\" (lifecycle dependent)",
        "```",
        "House ◆────── Room",
        "      contains",
        "```",
        "Room cannot exist without House.",
        "",
        "**4. Inheritance** (hollow arrow): \"is-a\" relationship",
        "```",
        "Animal △───── Dog",
        "         ↑",
        "         extends",
        "```",
        "",
        "**5. Implementation** (dashed arrow + hollow tip): implements interface",
        "```",
        "PaymentMethod △- - - CreditCard",
        "              ↑",
        "              implements",
        "```",
        "",
        "### Example 1: E-Commerce System",
        "",
        "```",
        "┌─────────────────────┐",
        "│      Customer       │",
        "├─────────────────────┤",
        "│ - id: string        │",
        "│ - name: string      │",
        "│ - email: string     │",
        "├─────────────────────┤",
        "│ + placeOrder()      │",
        "│ + viewOrders()      │",
        "└─────────────────────┘",
        "          │",
        "          │ places",
        "          ▼",
        "┌─────────────────────┐        ┌──────────────┐",
        "│        Order        │◆──────│  OrderItem   │",
        "├─────────────────────┤ 1   * ├──────────────┤",
        "│ - orderId           │        │ - quantity   │",
        "│ - date              │        │ - price      │",
        "│ - total             │        └──────────────┘",
        "├─────────────────────┤              │",
        "│ + calculateTotal()  │              │ references",
        "│ + addItem()         │              ▼",
        "└─────────────────────┘        ┌──────────────┐",
        "                               │   Product    │",
        "                               ├──────────────┤",
        "                               │ - productId  │",
        "                               │ - name       │",
        "                               │ - price      │",
        "                               ├──────────────┤",
        "                               │ + getPrice() │",
        "                               └──────────────┘",
        "```",
        "",
        "**Key**: 1 Order has many (*) OrderItems (composition).",
        "",
        "### Example 2: Parking Lot System",
        "",
        "```",
        "┌──────────────┐",
        "│  ParkingLot  │",
        "├──────────────┤",
        "│ - name       │",
        "│ - address    │",
        "├──────────────┤",
        "│ + addLevel() │",
        "└──────────────┘",
        "       ◆",
        "       │ contains",
        "       │ 1..*",
        "       ▼",
        "┌──────────────┐",
        "│ ParkingLevel │",
        "├──────────────┤",
        "│ - levelId    │",
        "│ - floor      │",
        "├──────────────┤",
        "│ + addSpot()  │",
        "└──────────────┘",
        "       ◆",
        "       │ contains",
        "       │ 1..*",
        "       ▼",
        "┌──────────────────┐              ┌──────────────┐",
        "│  ParkingSpot     │              │   Vehicle    │",
        "├──────────────────┤              ├──────────────┤      ┌─────────┐",
        "│ - spotId         │◇────────────│ - plateNumber│      │   Car   │",
        "│ - spotType       │   parks in  │ - type       │◁─────┤         │",
        "│ - isAvailable    │             └──────────────┘      └─────────┘",
        "├──────────────────┤                    △",
        "│ + parkVehicle()  │                    │",
        "│ + removeVehicle()│                    │              ┌─────────┐",
        "└──────────────────┘                    └──────────────│  Truck  │",
        "                                                       └─────────┘",
        "```",
        "",
        "## Sequence Diagrams",
        "Show how objects interact over time (message flow).",
        "",
        "### Example: User Login Flow",
        "",
        "```",
        "User        UI          Controller    AuthService   Database",
        " │           │               │              │            │",
        " │  Login    │               │              │            │",
        " ├──────────>│               │              │            │",
        " │           │ authenticate()│              │            │",
        " │           ├──────────────>│              │            │",
        " │           │               │ validate()   │            │",
        " │           │               ├─────────────>│            │",
        " │           │               │              │getUser()   │",
        " │           │               │              ├───────────>│",
        " │           │               │              │    User    │",
        " │           │               │              │<───────────┤",
        " │           │               │  checkPwd()  │            │",
        " │           │               │<─────────────┤            │",
        " │           │               │ generateToken│            │",
        " │           │               ├─────────────>│            │",
        " │           │               │    token     │            │",
        " │           │  loginSuccess │<─────────────┤            │",
        " │           │<──────────────┤              │            │",
        " │ Dashboard │               │              │            │",
        " │<──────────┤               │              │            │",
        " │           │               │              │            │",
        "```",
        "",
        "### Example: Online Shopping - Add to Cart",
        "",
        "```",
        "Customer   ShopUI    CartController   Cart      Product    Inventory",
        "   │         │            │            │           │            │",
        "   │ Click   │            │            │           │            │",
        "   │ Add     │            │            │           │            │",
        "   ├────────>│            │            │           │            │",
        "   │         │ addToCart()│            │           │            │",
        "   │         ├───────────>│            │           │            │",
        "   │         │            │ getProduct()           │            │",
        "   │         │            ├───────────────────────>│            │",
        "   │         │            │         Product        │            │",
        "   │         │            │<───────────────────────┤            │",
        "   │         │            │ checkStock()           │            │",
        "   │         │            ├───────────────────────────────────>│",
        "   │         │            │         Available      │            │",
        "   │         │            │<───────────────────────────────────┤",
        "   │         │            │ add(item)  │           │            │",
        "   │         │            ├───────────>│           │            │",
        "   │         │            │     OK     │           │            │",
        "   │         │  Success   │<───────────┤           │            │",
        "   │ Updated │<───────────┤            │           │            │",
        "   │<────────┤            │            │           │            │",
        "```",
        "",
        "## Use Case Diagrams",
        "Show system functionality from user perspective.",
        "",
        "### Example: ATM System",
        "",
        "```",
        "                    ┌──────────────────────────┐",
        "                    │      ATM System          │",
        "  ┌──────┐         │                          │",
        "  │ User │────────>│  ○ Withdraw Cash          │",
        "  └──────┘         │                          │",
        "                   │  ○ Check Balance         │",
        "                   │                          │",
        "                   │  ○ Deposit Cash          │",
        "                   │                          │",
        "                   │  ○ Transfer Money        │",
        "                   │                          │",
        "  ┌──────────┐    │  ○ Change PIN            │    ┌───────────┐",
        "  │   Bank   │────│                          │────│  Receipt  │",
        "  │  System  │    │  ○ Print Receipt         │    │  Printer  │",
        "  └──────────┘    │                          │    └───────────┘",
        "                   └──────────────────────────┘",
        "```",
        "",
        "## Activity Diagrams",
        "Show workflow/process flow (like a flowchart).",
        "",
        "### Example: Order Processing",
        "",
        "```",
        "          (Start)",
        "             │",
        "             ▼",
        "      [Receive Order]",
        "             │",
        "             ▼",
        "      <Item in Stock?>",
        "         /        \\",
        "       Yes        No",
        "        │          │",
        "        │          ▼",
        "        │    [Notify Customer]",
        "        │          │",
        "        │          ▼",
        "        │    [Wait for Restock]",
        "        │          │",
        "        └──────────┘",
        "             │",
        "             ▼",
        "      [Process Payment]",
        "             │",
        "             ▼",
        "      <Payment Success?>",
        "         /        \\",
        "       Yes        No",
        "        │          │",
        "        │          ▼",
        "        │    [Cancel Order]",
        "        │          │",
        "        │          ▼",
        "        │         (End)",
        "        │",
        "        ▼",
        "   [Ship Order]",
        "        │",
        "        ▼",
        "   [Send Tracking]",
        "        │",
        "        ▼",
        "      (End)",
        "```",
        "",
        "## Interview Tips",
        "",
        "**When to Use Which Diagram**:",
        "- **Class Diagram**: Static structure, relationships",
        "- **Sequence Diagram**: Message flow, API interactions",
        "- **Use Case Diagram**: System requirements, actors",
        "- **Activity Diagram**: Business logic, workflows",
        "",
        "**Best Practices**:",
        "1. Start with class diagram for structure",
        "2. Use sequence diagram for complex interactions",
        "3. Keep diagrams simple - focus on key components",
        "4. Don't draw every class - highlight important ones",
        "5. Use pen & paper in interviews for speed",
        "",
        "## Common Interview Questions",
        "",
        "1. **Design a Parking Lot**: Use class diagram for Vehicle, ParkingSpot, Level hierarchy",
        "2. **Design an Elevator**: Sequence diagram for request handling",
        "3. **Design a Library System**: Class diagram for Book, Member, Loan relationships",
        "4. **Design Uber**: Activity diagram for ride request flow"
      ],
      "keyPoints": [
        "Class diagrams show structure (classes, relationships, cardinality)",
        "Sequence diagrams show behavior (message flow over time)",
        "Use case diagrams show functionality from user perspective",
        "Activity diagrams show workflows and business processes",
        "Tools: draw.io, Lucidchart, or pen and paper"
      ]
    },
    {
      "id": "lld-interview-tips",
      "title": "5 Tips to Crack LLD Interviews",
      "description": "Strategies for low-level design success",
      "content": [
        "Low-level design (LLD) interviews differ from high-level design. Focus is on classes, objects, and design patterns rather than infrastructure.",
        "",
        "## Key Mindset",
        "",
        "**No Right or Wrong Answer**: LLD is an iterative process. Your goal is a design good enough to convince the interviewer in limited time.",
        "",
        "**Start Small, Build Up**: Always start with basic entities, then progressively build toward higher components. This reduces the chance of missing fundamentals.",
        "",
        "**Time is Limited**: You have 45-60 minutes. Don't design everything in your head first—discuss as you go.",
        "",
        "## Tip 1: Understand and Read the Question Properly",
        "",
        "**Don't Rush**: Even if you've seen the question before, don't blindly recite a memorized answer.",
        "",
        "**Listen Carefully**: Requirements may differ from what you've studied. Stay calm and listen to the interviewer.",
        "",
        "**Adapt to Context**: The interviewer may have different expectations. Don't sound like you're copy-pasting.",
        "",
        "**Example**: Design a parking lot",
        "- Even if you've practiced this, ask specific questions:",
        "  - Q: Multi-level or single level?",
        "  - Q: Different vehicle types? (Car, Truck, Motorcycle)",
        "  - Q: Payment system needed?",
        "  - Q: Do we need to track parking duration?",
        "",
        "## Tip 2: List the Requirements",
        "",
        "**Don't Assume—Clarify**: Ask questions and write down ALL requirements.",
        "",
        "**Why This Matters**:",
        "- Prevents confusion later",
        "- Provides clear reference for what to do next",
        "- Becomes the foundation for your design",
        "- Allows step-by-step progression",
        "",
        "**Process**:",
        "1. Ask clarifying questions",
        "2. Write down functional requirements",
        "3. Write down non-functional requirements (scale, performance)",
        "4. Write down constraints (memory, single/multi-threaded)",
        "5. Use this list as your design checklist",
        "",
        "**Without Requirements**: You'll be lost during design with no clear direction.",
        "",
        "## Tip 3: Think Out Loud and Be Clear",
        "",
        "**Discuss Your Approach**: After gathering requirements, take a moment to think, then discuss your approach with the interviewer.",
        "",
        "**Collaborate During Design**: Don't design in silence for 30 minutes then present. The interviewer will guide you.",
        "",
        "**Benefits of Discussion**:",
        "- Interviewer can provide hints if you go wrong",
        "- Saves time on corrections",
        "- Shows your thought process",
        "- Demonstrates communication skills",
        "",
        "**Remember**: The interviewer wants to hire you, not reject you. It's okay to seek hints, but don't ask at every single step.",
        "",
        "**Common Mistake**: Thinking everything through alone, then explaining. This wastes time and misses guidance opportunities.",
        "",
        "## Tip 4: Apply OOP Principles",
        "",
        "**Use the 4 Pillars**:",
        "",
        "**Encapsulation**: Hide implementation details",
        "```typescript",
        "class ParkingSpot {",
        "  private isOccupied: boolean;",
        "  ",
        "  park(vehicle: Vehicle): boolean {",
        "    if (this.isOccupied) return false;",
        "    this.isOccupied = true;",
        "    return true;",
        "  }",
        "}",
        "```",
        "",
        "**Inheritance**: IS-A relationship",
        "```typescript",
        "abstract class Vehicle {}",
        "class Car extends Vehicle {}",
        "class Truck extends Vehicle {}",
        "```",
        "",
        "**Polymorphism**: Same interface, different behavior",
        "```typescript",
        "interface ParkingStrategy {",
        "  findSpot(lot: ParkingLot, vehicle: Vehicle): ParkingSpot;",
        "}",
        "",
        "class NearestSpotStrategy implements ParkingStrategy {...}",
        "class LargestSpotStrategy implements ParkingStrategy {...}",
        "```",
        "",
        "**Abstraction**: Hide complexity",
        "```typescript",
        "interface PaymentProcessor {",
        "  processPayment(amount: number): boolean;",
        "}",
        "```",
        "",
        "## Tip 5: Practice, Practice, Practice",
        "",
        "**Don't Underestimate Practice**: Consistency is the key to mastery.",
        "",
        "**Effective Practice Method**:",
        "1. **Try First**: Attempt the design on your own",
        "2. **Compare**: Then look at available solutions",
        "3. **Analyze**: What did you miss? What could be better?",
        "",
        "**Common Mistake**: Reading solutions without attempting first. This severely limits your learning.",
        "",
        "**Before Interviews**:",
        "- Review your notes or study materials",
        "- You may get lucky with a question you've practiced",
        "- But remember: Don't blindly recite—adapt to the specific requirements",
        "",
        "**Practice Strategy**:",
        "- Take 5-10 common LLD questions",
        "- Design them yourself first",
        "- Document your approach",
        "- Compare with multiple solutions",
        "- Understand trade-offs",
        "",
        "## Recognize and Apply Design Patterns",
        "",
        "**Common Patterns in LLD**:",
        "",
        "**Singleton**: Single instance (ParkingLot, Logger)",
        "```typescript",
        "class ParkingLot {",
        "  private static instance: ParkingLot;",
        "  ",
        "  static getInstance(): ParkingLot {",
        "    if (!this.instance) {",
        "      this.instance = new ParkingLot();",
        "    }",
        "    return this.instance;",
        "  }",
        "}",
        "```",
        "",
        "**Factory**: Create objects without specifying exact class",
        "```typescript",
        "class VehicleFactory {",
        "  static createVehicle(type: string): Vehicle {",
        "    if (type === 'car') return new Car();",
        "    if (type === 'truck') return new Truck();",
        "  }",
        "}",
        "```",
        "",
        "**Strategy**: Interchangeable algorithms",
        "```typescript",
        "class ParkingLot {",
        "  constructor(private strategy: ParkingStrategy) {}",
        "  ",
        "  findSpot(vehicle: Vehicle) {",
        "    return this.strategy.findSpot(this, vehicle);",
        "  }",
        "}",
        "```",
        "",
        "**Observer**: Notify on state change",
        "```typescript",
        "class ParkingLot {",
        "  private observers: Observer[] = [];",
        "  ",
        "  notifySpotAvailable(spot: ParkingSpot) {",
        "    this.observers.forEach(o => o.update(spot));",
        "  }",
        "}",
        "```",
        "",
        "## Follow SOLID Principles",
        "",
        "**S - Single Responsibility**: One class, one job",
        "❌ Bad: `ParkingLot` handles parking AND payment",
        "✅ Good: `ParkingLot` handles parking, `PaymentService` handles payment",
        "",
        "**O - Open/Closed**: Extend, don't modify",
        "❌ Bad: Modify `ParkingLot` to add motorcycles",
        "✅ Good: Create `MotorcycleSpot extends ParkingSpot`",
        "",
        "**L - Liskov Substitution**: Subtypes must work where base types work",
        "❌ Bad: `Square extends Rectangle` (breaks expectations)",
        "✅ Good: Use composition or interfaces",
        "",
        "**I - Interface Segregation**: Small, focused interfaces",
        "❌ Bad: `IVehicle { drive(), fly(), sail() }`",
        "✅ Good: `IDrivable`, `IFlyable`, `ISailable`",
        "",
        "**D - Dependency Inversion**: Depend on abstractions",
        "❌ Bad: `ParkingLot` directly creates `CreditCardPayment`",
        "✅ Good: `ParkingLot` depends on `IPaymentProcessor` interface",
        "",
        "## Interview Flow",
        "",
        "1. **Clarify** (5 min): Ask questions, list requirements",
        "2. **Use Cases** (5 min): List actors and actions",
        "3. **Class Diagram** (10 min): Draw classes, relationships",
        "4. **Code Key Classes** (15 min): Implement 2-3 core classes",
        "5. **Discuss** (5-10 min): Trade-offs, extensibility, refactoring",
        "",
        "## What Interviewers Look For",
        "",
        "✅ **Clear thinking**: Structured approach",
        "✅ **Communication**: Discussing as you design",
        "✅ **OOP mastery**: Proper use of principles",
        "✅ **Pattern knowledge**: When and why to use patterns",
        "✅ **SOLID principles**: Maintainable design",
        "✅ **Flexibility**: Adapting to feedback",
        "✅ **Testability**: Design that's easy to test"
      ],
      "keyPoints": [
        "Start with basic entities, build up progressively",
        "List all requirements before designing—don't assume",
        "Think out loud and discuss as you design, not after",
        "Practice by trying first, then comparing with solutions",
        "Apply OOP principles and design patterns appropriately"
      ]
    },
    {
      "id": "ood-approach",
      "title": "6 Steps to Approach OOD Questions",
      "description": "Framework for object-oriented design interviews",
      "content": [
        "Use this systematic framework to tackle any object-oriented design question.",
        "",
        "## Step 1: Understand Requirements (5 min)",
        "",
        "**Ask Clarifying Questions**:",
        "",
        "**Example**: Design a Chess Game",
        "- Q: Single player vs computer or two players?",
        "- Q: Do we need move validation?",
        "- Q: Undo/Redo functionality?",
        "- Q: Save/Load game state?",
        "- Q: Timer support?",
        "",
        "**Output**: List of features",
        "- ✅ Two-player chess",
        "- ✅ Move validation",
        "- ✅ Check/Checkmate detection",
        "- ❌ No AI opponent (out of scope)",
        "- ❌ No timer (out of scope)",
        "",
        "## Step 2: Define Use Cases (5 min)",
        "",
        "**Identify Actors and Actions**:",
        "",
        "**Chess Game Example**:",
        "",
        "**Actors**: Player (White), Player (Black), Game",
        "",
        "**Use Cases**:",
        "1. Start new game",
        "2. Player selects piece",
        "3. Player moves piece",
        "4. Game validates move",
        "5. Game updates board",
        "6. Game checks for check/checkmate",
        "7. Game switches turn",
        "8. Game ends (checkmate, stalemate, resign)",
        "",
        "## Step 3: Identify Core Objects (10 min)",
        "",
        "**Nouns in use cases become classes**:",
        "",
        "**Chess Game Objects**:",
        "- `Game`: Orchestrates gameplay",
        "- `Board`: 8×8 grid of cells",
        "- `Cell`: Single square on board",
        "- `Piece`: Abstract base class",
        "  - `King`, `Queen`, `Rook`, `Bishop`, `Knight`, `Pawn`",
        "- `Player`: White or Black",
        "- `Move`: Represents a move (from, to)",
        "",
        "**Relationships**:",
        "- `Game` HAS-A `Board`",
        "- `Board` HAS-MANY `Cell`",
        "- `Cell` HAS-A `Piece`",
        "- `Piece` IS-A `King`, `Queen`, etc.",
        "- `Game` HAS-TWO `Player`",
        "",
        "## Step 4: Draw Class Diagram (10 min)",
        "",
        "```",
        "┌──────────────┐",
        "│     Game     │",
        "├──────────────┤",
        "│ - board      │",
        "│ - players[2] │",
        "│ - currentTurn│",
        "├──────────────┤",
        "│ + start()    │",
        "│ + makeMove() │",
        "│ + isCheckmate()│",
        "└──────────────┘",
        "       │",
        "       │ HAS-A",
        "       ▼",
        "┌──────────────┐       ┌──────────────┐",
        "│    Board     │       │     Cell     │",
        "├──────────────┤       ├──────────────┤",
        "│ - cells[][]  │◆─────│ - position   │",
        "├──────────────┤       │ - piece      │",
        "│ + getCell()  │       └──────────────┘",
        "│ + resetBoard()│              │",
        "└──────────────┘              │ HAS-A",
        "                              ▼",
        "                       ┌──────────────┐",
        "                       │    Piece     │ (Abstract)",
        "                       ├──────────────┤",
        "                       │ - color      │",
        "                       │ - hasMoved   │",
        "                       ├──────────────┤",
        "                       │ + canMove()  │ (Abstract)",
        "                       └──────────────┘",
        "                              △",
        "                              │",
        "              ┌───────────────┼───────────────┐",
        "              │               │               │",
        "         ┌────────┐      ┌────────┐     ┌────────┐",
        "         │  King  │      │ Queen  │ ... │  Pawn  │",
        "         └────────┘      └────────┘     └────────┘",
        "```",
        "",
        "## Step 5: Define Key Methods (15 min)",
        "",
        "**Implement Core Classes**:",
        "",
        "```typescript",
        "abstract class Piece {",
        "  constructor(",
        "    protected color: 'white' | 'black',",
        "    protected position: Position",
        "  ) {}",
        "  ",
        "  abstract canMove(to: Position, board: Board): boolean;",
        "}",
        "",
        "class King extends Piece {",
        "  canMove(to: Position, board: Board): boolean {",
        "    // King moves 1 square in any direction",
        "    const dx = Math.abs(to.x - this.position.x);",
        "    const dy = Math.abs(to.y - this.position.y);",
        "    return dx <= 1 && dy <= 1;",
        "  }",
        "}",
        "",
        "class Pawn extends Piece {",
        "  canMove(to: Position, board: Board): boolean {",
        "    // Pawn moves forward 1 (or 2 from start)",
        "    const direction = this.color === 'white' ? 1 : -1;",
        "    const dy = to.y - this.position.y;",
        "    ",
        "    if (dy === direction && to.x === this.position.x) {",
        "      return !board.getCell(to).hasPiece();",
        "    }",
        "    // ... handle captures, en passant",
        "    return false;",
        "  }",
        "}",
        "",
        "class Game {",
        "  private board: Board;",
        "  private players: Player[];",
        "  private currentTurn: number = 0;",
        "  ",
        "  makeMove(from: Position, to: Position): boolean {",
        "    const piece = this.board.getCell(from).getPiece();",
        "    if (!piece) return false;",
        "    ",
        "    if (!piece.canMove(to, this.board)) return false;",
        "    ",
        "    this.board.movePiece(from, to);",
        "    ",
        "    if (this.isCheckmate()) {",
        "      this.endGame();",
        "    } else {",
        "      this.switchTurn();",
        "    }",
        "    ",
        "    return true;",
        "  }",
        "  ",
        "  private isCheckmate(): boolean {",
        "    // Check if current player's king is in checkmate",
        "    // ...",
        "  }",
        "}",
        "```",
        "",
        "## Step 6: Discuss Design Decisions (5 min)",
        "",
        "**Trade-offs and Extensions**:",
        "",
        "**Design Pattern Used**:",
        "- **Strategy Pattern**: Each piece has its own move validation strategy",
        "- **Template Method**: `Piece.canMove()` defines algorithm skeleton",
        "",
        "**Extensibility**:",
        "- Add new piece types? Extend `Piece` class",
        "- Add move history? Introduce `MoveHistory` class",
        "- Add AI? Create `AIPlayer extends Player`",
        "",
        "**SOLID Compliance**:",
        "- ✅ SRP: Each piece handles its own move logic",
        "- ✅ OCP: Can add new pieces without modifying existing code",
        "- ✅ LSP: All pieces are substitutable for `Piece`",
        "- ✅ DIP: `Game` depends on `Piece` abstraction, not concrete pieces",
        "",
        "**Potential Issues**:",
        "- Special moves (castling, en passant): Needs extra logic",
        "- Game state persistence: Add serialization",
        "- Multiplayer: Add network layer",
        "",
        "## Summary Checklist",
        "",
        "- [ ] Clarified requirements",
        "- [ ] Listed use cases",
        "- [ ] Identified core objects",
        "- [ ] Drew class diagram",
        "- [ ] Coded 2-3 key classes",
        "- [ ] Discussed design patterns",
        "- [ ] Mentioned SOLID principles",
        "- [ ] Addressed extensibility"
      ],
      "keyPoints": [
        "Step 1: Understand requirements with clarifying questions",
        "Step 2: Define actors and use cases",
        "Step 3: Identify core objects from nouns in use cases",
        "Step 4: Draw class diagram with relationships",
        "Step 5: Implement 2-3 key classes with core methods",
        "Step 6: Discuss design decisions, patterns, and extensibility"
      ]
    }
  ]
}