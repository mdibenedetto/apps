{
  "id": "system-design",
  "title": "System Design",
  "description": "Learn to design scalable distributed systems",
  "icon": "Network",
  "color": "system-design",
  "introduction": "System Design interviews evaluate your ability to design large-scale distributed systems. These interviews test your understanding of scalability, reliability, and real-world tradeoffs. Success requires combining theoretical knowledge with practical experience to create systems that can handle millions of users.",
  "topics": [
    {
      "id": "getting-started",
      "title": "Getting Started with System Design",
      "description": "Introduction to HLD and LLD",
      "content": [
        "System Design is a crucial phase in software development that provides the backbone for building robust, scalable systems.",
        "",
        "## System Design in SDLC",
        "",
        "**Why It Matters**:",
        "- Without the design phase, you cannot jump to implementation or testing",
        "- Represents the business logic of the software",
        "- Provides the framework to handle exceptional scenarios",
        "- Ensures all stakeholders understand the system architecture",
        "",
        "## High-Level Design (HLD)",
        "",
        "**What It Is**: Lays out the overall architecture—how major components interact, what services exist, and how data flows.",
        "",
        "**Big Picture Focus**:",
        "- How the system fits together",
        "- Core structure and major decisions",
        "- Component interactions and data flow",
        "",
        "**Who Does It**: Architects, senior engineers, stakeholders, and managers",
        "",
        "### Topics Covered in HLD",
        "",
        "1. **System Architecture Overview**",
        "   - Major components, modules, and their interactions",
        "   - Services, queues, databases",
        "",
        "2. **Data Flow and Component Interaction**",
        "   - How data moves between modules",
        "   - Key integrations and interfaces",
        "",
        "3. **Technology Stack**",
        "   - Frameworks, platforms, databases",
        "   - Hosting and infrastructure decisions",
        "",
        "4. **Module Responsibilities**",
        "   - What each module does",
        "   - How modules relate to each other",
        "",
        "5. **Performance & Trade-offs**",
        "   - Design trade-offs",
        "   - Scalability, security, cost",
        "   - Non-functional factors",
        "",
        "6. **Artifacts**",
        "   - Architecture diagrams",
        "   - Component and deployment diagrams",
        "   - Data flow diagrams",
        "   - ER/DB schema overviews",
        "",
        "### Prerequisites for HLD",
        "",
        "**Technical Knowledge Required**:",
        "- **Basic Coding**: Data structures and algorithms",
        "- **Components**: Databases (SQL/NoSQL), Caches (Redis, Memcached, CDN), APIs",
        "- **LLD Foundation**: OOP and design patterns",
        "- **Requirements**: Functional vs Non-functional (scalability, latency, availability, security)",
        "- **Networking**: DNS, TCP/UDP, HTTP, WebSockets, OAuth, JWT, TLS/SSL",
        "- **Message Queues**: Kafka, RabbitMQ",
        "- **Architecture**: Microservices vs Monoliths, fault tolerance, load balancers",
        "- **Observability**: Prometheus, Grafana, ELK Stack, PagerDuty",
        "",
        "### Real-World HLD Examples",
        "",
        "**Netflix** (2011):",
        "- Transitioned from monolith to microservices",
        "- Started with encoding and UI services",
        "- Goal: Scale rapidly during holiday seasons",
        "",
        "**Uber**:",
        "- Event-driven architecture",
        "- Ride requests, location updates, fare changes emit events",
        "- Triggers: Driver matching, billing, dynamic pricing",
        "",
        "**Twitter**:",
        "- Load-balanced architecture",
        "- Caching of trending topics and tweets",
        "- Serves millions of users with real-time data",
        "",
        "## Low-Level Design (LLD)",
        "",
        "**What It Is**: Detailed blueprint of individual components—classes, methods, data structures, algorithms.",
        "",
        "**Detail Focus**:",
        "- How each component works internally",
        "- Class structures and relationships",
        "- Specific algorithms and data flows",
        "",
        "**Who Does It**: Developers and engineers implementing the system",
        "",
        "### Topics Covered in LLD",
        "",
        "1. **Class Diagrams**",
        "   - Classes, attributes, methods",
        "   - Relationships (inheritance, composition, aggregation)",
        "",
        "2. **Sequence Diagrams**",
        "   - Object interactions over time",
        "   - Method call sequences",
        "",
        "3. **Design Patterns**",
        "   - Creational, Structural, Behavioral patterns",
        "   - When and how to apply them",
        "",
        "4. **SOLID Principles**",
        "   - Single Responsibility",
        "   - Open/Closed",
        "   - Liskov Substitution",
        "   - Interface Segregation",
        "   - Dependency Inversion",
        "",
        "5. **Detailed Algorithms**",
        "   - Pseudocode or actual implementation",
        "   - Time/space complexity",
        "",
        "6. **Database Schema**",
        "   - Tables, columns, data types",
        "   - Indexes, constraints, relationships",
        "",
        "### Prerequisites for LLD",
        "",
        "**What You Should Know**:",
        "- **Object-Oriented Programming**: Classes, inheritance, polymorphism, encapsulation",
        "- **Design Patterns**: Factory, Singleton, Observer, Strategy, etc.",
        "- **SOLID Principles**: How to write maintainable code",
        "- **UML Diagrams**: Class, sequence, use case diagrams",
        "- **Data Structures**: How to choose the right one",
        "",
        "## Steps for Getting Started",
        "",
        "### 1. Understand Requirements",
        "**Gather and analyze business needs**:",
        "- Consult stakeholders, users, documentation",
        "- Define functional and non-functional requirements",
        "- Clarify scope and constraints",
        "",
        "### 2. Define Architecture",
        "**Identify key components**:",
        "- Services, APIs, databases",
        "- How they interact",
        "- Data flow between components",
        "",
        "### 3. Choose Tech Stack",
        "**Select appropriate technologies**:",
        "- Languages, frameworks",
        "- Databases (SQL vs NoSQL)",
        "- Tools and platforms",
        "",
        "### 4. Design Modules",
        "**Break system into modules**:",
        "- Define responsibilities",
        "- Establish data flow",
        "- Document interfaces",
        "",
        "### 5. Plan for Scalability",
        "**Design with growth in mind**:",
        "- Anticipate load increases",
        "- Optimize bottlenecks",
        "- Use scalable patterns",
        "",
        "### 6. Ensure Security & Privacy",
        "**Identify and mitigate risks**:",
        "- Authentication and authorization",
        "- Encryption (data in transit and at rest)",
        "- Data protection and privacy",
        "",
        "### 7. Test & Validate",
        "**Ensure system meets requirements**:",
        "- Write test cases",
        "- Simulate real-world usage",
        "- Load testing and stress testing",
        "",
        "## Approaching a Design Problem",
        "",
        "### 1. Breaking Down the Problem",
        "",
        "**Start Small**: Break the system into smaller components (services, features).",
        "",
        "**Ask About Scope**: In interviews, you're not expected to design everything.",
        "- \"Which features should I prioritize?\"",
        "- \"Are there any services I should include?\"",
        "- \"What can we defer for v2?\"",
        "",
        "### 2. Communicating Your Ideas",
        "",
        "**Keep Interviewer in the Loop**:",
        "- Discuss your process out loud",
        "- Draw flowcharts and diagrams",
        "- Describe your approach to:",
        "  - Scalability",
        "  - Database design",
        "  - Trade-offs",
        "",
        "**Use Visual Aids**: Whiteboard diagrams are more effective than verbal descriptions alone.",
        "",
        "### 3. Making Reasonable Assumptions",
        "",
        "**Numbers to Estimate**:",
        "- Requests processed per day",
        "- Database calls per month",
        "- Cache hit rate",
        "- Storage growth rate",
        "",
        "**Back Up Assumptions**: Use solid facts and figures. Explain your reasoning.",
        "",
        "**Example**: \"Assuming 1M daily active users, each making 10 requests/day, that's 10M requests/day or ~115 QPS. During peak hours (10% of traffic in 2 hours), we'd see ~500 QPS.\"",
        "",
        "## Important Points When Designing",
        "",
        "1. **No Single Right Answer**: Multiple valid approaches exist",
        "2. **Iterative Process**: Design evolves as you understand requirements",
        "3. **Think Out Loud**: Show your thought process",
        "4. **Ask Questions**: Clarify ambiguities early",
        "5. **Consider Trade-offs**: Every decision has pros and cons",
        "6. **Start Simple**: Build complexity incrementally",
        "7. **Justify Choices**: Explain why you chose X over Y"
      ],
      "keyPoints": [
        "HLD focuses on architecture and component interactions",
        "LLD focuses on classes, methods, and implementation details",
        "Break problems into smaller components",
        "Communicate your process clearly with diagrams",
        "Make reasonable assumptions backed by calculations"
      ]
    },
    {
      "id": "functional-vs-non-functional",
      "title": "Functional vs Non-Functional Requirements",
      "description": "Understanding what vs how in system design",
      "content": [
        "Requirements are the foundation of system design. Understanding the difference between functional and non-functional requirements is crucial for designing robust systems.",
        "",
        "## What are Functional Requirements?",
        "",
        "**Definition**: Functional requirements define the specific features and operations a system must perform to meet business and user needs.",
        "",
        "**Focus**: What the system should **DO**",
        "",
        "**Characteristics**:",
        "- Describe system behavior and functionality",
        "- Represent features that can be directly observed and tested",
        "- Tied to business needs and user actions",
        "- Can be validated through functional testing",
        "",
        "**Common Examples**:",
        "- User authentication and authorization",
        "- Data processing and validation",
        "- Search and filtering functionality",
        "- Payment handling and transaction processing",
        "- Report generation and data export",
        "- CRUD operations (Create, Read, Update, Delete)",
        "",
        "## What are Non-Functional Requirements?",
        "",
        "**Definition**: Non-functional requirements (NFRs) define how a system should operate, focusing on performance, reliability, and user experience.",
        "",
        "**Focus**: **HOW WELL** the system should perform",
        "",
        "**Key Categories**:",
        "",
        "### 1. Performance",
        "- Speed and responsiveness",
        "- Throughput (requests per second)",
        "- Latency (response time)",
        "",
        "### 2. Security",
        "- Protection against unauthorized access",
        "- Data encryption (in transit and at rest)",
        "- Authentication and authorization mechanisms",
        "- Compliance with security standards",
        "",
        "### 3. Usability",
        "- Ease of use and learning curve",
        "- User interface intuitiveness",
        "- Accessibility features",
        "",
        "### 4. Reliability",
        "- System stability and uptime",
        "- Error handling and recovery",
        "- Data integrity",
        "",
        "### 5. Scalability",
        "- Ability to handle growth",
        "- Horizontal and vertical scaling capabilities",
        "- Load handling during peak times",
        "",
        "### 6. Maintainability",
        "- Ease of updates and bug fixes",
        "- Code quality and documentation",
        "- Modularity and testability",
        "",
        "### 7. Portability",
        "- Ability to run in different environments",
        "- Cross-platform compatibility",
        "- Cloud vs on-premise flexibility",
        "",
        "## Examples from Real Systems",
        "",
        "### 1. Online Banking System",
        "",
        "**Functional Requirements**:",
        "- Users can log in with username and password",
        "- Users can check account balance",
        "- Users can transfer money between accounts",
        "- Users receive notifications after transactions",
        "- Users can view transaction history",
        "",
        "**Non-Functional Requirements**:",
        "- System responds to user actions in <2 seconds (Performance)",
        "- All transactions encrypted with AES-256 (Security)",
        "- 99.99% uptime (Reliability)",
        "- Support 100 million users with minimal downtime (Scalability)",
        "- Comply with PCI-DSS and banking regulations (Security/Compliance)",
        "",
        "### 2. Food Delivery App",
        "",
        "**Functional Requirements**:",
        "- Users can browse restaurant menus",
        "- Users can place orders",
        "- Users can make payments",
        "- Users can track orders in real-time",
        "- Restaurants can update menu and availability",
        "",
        "**Non-Functional Requirements**:",
        "- Menu loads in <1 second (Performance)",
        "- Support 50,000 concurrent orders during peak hours (Scalability)",
        "- Intuitive interface for first-time users (Usability)",
        "- 99.9% payment success rate (Reliability)",
        "- GPS tracking updates every 30 seconds (Performance)",
        "",
        "## Key Differences",
        "",
        "| Aspect | Functional Requirements | Non-Functional Requirements |",
        "|--------|------------------------|-----------------------------|",
        "| **Definition** | What the system should do | How well the system performs |",
        "| **Purpose** | Behavior and features | Performance and quality |",
        "| **Scope** | Actions and operations | Constraints and conditions |",
        "| **Measurement** | Easy - verify outputs | Harder - use benchmarks/SLAs |",
        "| **Impact** | Drive core design | Influence architecture |",
        "| **User Visibility** | Directly visible | Shape user experience |",
        "| **Documentation** | Use cases, user stories | Performance specs, constraints |",
        "| **Evaluation** | Functional testing | Performance, security, usability testing |",
        "| **Dependency** | Define what to build | Define how well it operates |",
        "| **Examples** | Login, search, payment | Speed, security, scalability |",
        "",
        "## Interview Application",
        "",
        "**When Asked to Design a System**:",
        "",
        "### Step 1: Clarify Functional Requirements",
        "\"What should the system do?\"",
        "- Core features (MVP)",
        "- User actions and workflows",
        "- Business logic",
        "",
        "### Step 2: Define Non-Functional Requirements",
        "\"How should it perform?\"",
        "- Expected scale (DAU, requests/sec)",
        "- Latency requirements (<100ms, <1s, <5s?)",
        "- Availability target (99%, 99.9%, 99.99%?)",
        "- Consistency vs Availability trade-off",
        "",
        "### Example: Design YouTube",
        "",
        "**Functional Requirements Questions**:",
        "- Q: \"Can users upload videos?\"",
        "- Q: \"Can users search and watch videos?\"",
        "- Q: \"Do we need comments and likes?\"",
        "- Q: \"Should we support live streaming?\"",
        "",
        "**Non-Functional Requirements Questions**:",
        "- Q: \"How many daily active users?\"",
        "- Q: \"What's the acceptable video start latency?\"",
        "- Q: \"What video quality should we support?\"",
        "- Q: \"What's our storage budget?\"",
        "",
        "## Common Mistakes to Avoid",
        "",
        "❌ **Skipping Non-Functional Requirements**: Designing only features without considering scale",
        "❌ **Vague NFRs**: \"System should be fast\" instead of \"Response time <200ms for 95% of requests\"",
        "❌ **Over-Engineering**: 99.999% availability when 99.9% is sufficient",
        "❌ **Ignoring Trade-offs**: Trying to maximize consistency AND availability",
        "",
        "## Best Practices",
        "",
        "✅ **Be Specific with NFRs**: Use numbers (\"<100ms latency\" not \"fast\")",
        "✅ **Prioritize**: Not all NFRs are equally important",
        "✅ **Document Both**: Write them down during interview",
        "✅ **Validate with Stakeholders**: Confirm understanding",
        "✅ **Consider Trade-offs**: Explicitly discuss (Consistency vs Availability, Cost vs Performance)",
        "",
        "## Why This Matters in Interviews",
        "",
        "**Demonstrates**:",
        "- Structured thinking (separating what from how)",
        "- Real-world experience (understanding trade-offs)",
        "- Communication skills (asking right questions)",
        "- Technical depth (knowing what affects architecture)",
        "",
        "**Interviewer Looks For**:",
        "- Do you ask about both functional and non-functional requirements?",
        "- Do you make reasonable assumptions for missing NFRs?",
        "- Do you design architecture based on NFRs (scale drives sharding, latency drives caching)?"
      ],
      "keyPoints": [
        "Functional = WHAT the system does (features, operations)",
        "Non-Functional = HOW WELL it performs (speed, security, scale)",
        "Always clarify both in interviews",
        "NFRs drive architecture decisions (caching, sharding, replication)",
        "Be specific with numbers for NFRs (not 'fast', but '<100ms')"
      ]
    },
    {
      "id": "high-level-design-deep-dive",
      "title": "High-Level Design Deep Dive",
      "description": "Comprehensive guide to HLD components and scalability",
      "content": [
        "High-Level Design (HLD) focuses on the overall system architecture and how components interact. This guide covers everything you need to master HLD.",
        "",
        "## Components of High-Level Design",
        "",
        "### 1. System Architecture",
        "Overview of the entire system showing structure and relationships between components.",
        "- Visual representation of component interactions",
        "- How different parts function together",
        "- Overall system structure",
        "",
        "### 2. Modules and Components",
        "Break down the system into modules with specific roles.",
        "- Each module has distinct functionality",
        "- Contributes to the entire system",
        "- Clear responsibilities and boundaries",
        "- Helps develop efficient systems",
        "",
        "### 3. Data Flow Diagrams (DFDs)",
        "Demonstrate how data moves within the system.",
        "- Information processing paths",
        "- Data passing from one component to another",
        "- Input/output relationships",
        "- Transformation points",
        "",
        "### 4. Interface Design",
        "Design of system interfaces for integration and interaction.",
        "- **APIs**: Application Programming Interfaces for system integration",
        "- **UIs**: User Interfaces for user interaction",
        "- Ensures seamless functionality",
        "- Enables communication between components",
        "",
        "### 5. Technology Stack",
        "Technologies and tools for system development.",
        "- Programming languages (Python, Java, Go, TypeScript)",
        "- Frameworks (Spring, Django, Express, React)",
        "- Databases (PostgreSQL, MongoDB, Redis, Cassandra)",
        "- Infrastructure tools (Docker, Kubernetes, AWS, GCP)",
        "",
        "### 6. Deployment Architecture",
        "How the system will be hosted and accessed.",
        "- Server configurations",
        "- Cloud infrastructure (AWS, Azure, GCP)",
        "- Network considerations",
        "- Load balancing and scaling strategies",
        "",
        "## What is an HLD Document?",
        "",
        "**Purpose**: Technical representation of functional requirements and information flow.",
        "",
        "**Contents**:",
        "- Data flows and flowcharts",
        "- Data structures",
        "- Component connections and operations",
        "- Architecture design for each module",
        "- Logic depicting system functionality",
        "",
        "**Characteristics**:",
        "- Diagrams representing each design aspect",
        "- Hardware, software, and user interface descriptions",
        "- User workflow details",
        "- Performance specifications",
        "- Based on business requirements and anticipated results",
        "",
        "## How to Design Scalable HLD Systems",
        "",
        "### 1. Capacity Estimation",
        "",
        "**What**: Predict resources needed for expected workload.",
        "",
        "**Resources to Estimate**:",
        "- Processing power (CPU cores)",
        "- Memory (RAM)",
        "- Storage (disk space)",
        "- Bandwidth (network capacity)",
        "",
        "**Purpose**:",
        "- Handle current and future demands efficiently",
        "- Proper resource allocation",
        "- Prevent performance bottlenecks",
        "",
        "**Example - Twitter**:",
        "- Popular influencer tweets reaching millions",
        "- Need to scale so service isn't hampered",
        "- Measured by throughput and latency",
        "",
        "### 2. HTTP and HTTPS Methods",
        "",
        "**HTTP**: Transfer data over the web",
        "- Enables client-server communication",
        "- Request resources (HTML, images, videos)",
        "",
        "**HTTPS**: HTTP + SSL/TLS encryption",
        "- Extra security layer",
        "- Protects data in transit",
        "",
        "**Common Methods**:",
        "- **GET**: Retrieve data",
        "- **POST**: Submit data",
        "- **PUT**: Update data",
        "- **DELETE**: Remove data",
        "- **PATCH**: Partial update",
        "",
        "**Interview Tip**: Know when to use each method in API design.",
        "",
        "### 3. WebSockets",
        "",
        "**What**: Full-duplex protocol for real-time communication.",
        "",
        "**Key Features**:",
        "- Send and receive data simultaneously",
        "- Bidirectional communication",
        "- Persistent connection",
        "- Low latency",
        "",
        "**Use Cases**:",
        "- Real-time web applications",
        "- Gaming applications",
        "- Chat applications",
        "- Live dashboards",
        "- Collaborative editing",
        "",
        "**Why Important**: Cannot let system wait for response in real-time scenarios.",
        "",
        "### 4. Polling",
        "",
        "**What**: Alternative way to get data from server.",
        "",
        "**Short Polling**:",
        "- Client sends requests at fixed intervals",
        "- Server responds immediately",
        "- May return empty if no new data",
        "- Higher network overhead",
        "",
        "**Long Polling**:",
        "- Client sends request",
        "- Server waits until new data is available",
        "- Then responds",
        "- Fewer requests than short polling",
        "",
        "**Interview Tip**: Long polling preferred over short polling (fewer requests).",
        "",
        "### 5. Server-Sent Events (SSE)",
        "",
        "**What**: One-way communication from server to client over HTTP.",
        "",
        "**Characteristics**:",
        "- Server pushes real-time updates",
        "- Automatic updates as data becomes available",
        "- Simpler than WebSockets for one-way data",
        "",
        "**Use Cases**:",
        "- Real-time streaming",
        "- News feeds",
        "- Stock price updates",
        "- Notifications",
        "",
        "**Comparison**:",
        "- SSE: One-way (server → client)",
        "- WebSockets: Two-way (server ↔ client)",
        "",
        "### 6. Rate Limiting",
        "",
        "**What**: Restrict number of requests in a timeframe.",
        "",
        "**Purpose**:",
        "- Prevent abuse",
        "- Ensure fair usage",
        "- Protect backend from overload",
        "- Manage costs",
        "",
        "**How It Works**:",
        "- Set threshold (e.g., 100 requests/minute)",
        "- Track requests per user/IP",
        "- Block when threshold reached",
        "- Return 429 (Too Many Requests)",
        "",
        "**Algorithms**:",
        "- **Token Bucket**: Add tokens at fixed rate",
        "- **Leaky Bucket**: Process requests at constant rate",
        "- **Fixed Window**: Reset counter each window",
        "- **Sliding Window**: More granular tracking",
        "",
        "### 7. Resiliency",
        "",
        "**Why Needed**: Systems can fail due to:",
        "- Hardware issues",
        "- Software bugs",
        "- Memory/resource exhaustion",
        "- Human error",
        "",
        "**How to Achieve**:",
        "",
        "**Replication**:",
        "- Multiple copies of data",
        "- If one fails, others available",
        "- Database replication (master-slave)",
        "",
        "**Redundancy**:",
        "- Backup components",
        "- Failover systems",
        "- Multiple availability zones",
        "",
        "**Availability**:",
        "- System remains operational",
        "- Graceful degradation",
        "- Circuit breakers",
        "- Retry mechanisms",
        "",
        "**Interview Importance**: Critical for complex system designs and interviews. Shows understanding of real-world constraints.",
        "",
        "### 8. Paging/Pagination",
        "",
        "**What**: Break large datasets into smaller chunks.",
        "",
        "**Why**:",
        "- Improve performance (less data transferred)",
        "- Better user experience",
        "- Reduce server load",
        "- Lower memory usage",
        "",
        "**Implementation**:",
        "- Page number + page size",
        "- Cursor-based (for real-time data)",
        "- Offset + limit",
        "",
        "**Example**: Twitter feed loads 20 tweets at a time.",
        "",
        "### 9. Logging and Monitoring",
        "",
        "**Logging**:",
        "- Record system events",
        "- Debug issues",
        "- Audit trail",
        "- Performance analysis",
        "",
        "**Monitoring**:",
        "- Track system health",
        "- Metrics (CPU, memory, latency)",
        "- Alerts on anomalies",
        "- Dashboards (Grafana, Datadog)",
        "",
        "**Tools**:",
        "- **Logging**: ELK Stack, Splunk, CloudWatch",
        "- **Monitoring**: Prometheus, Grafana, New Relic",
        "- **Tracing**: Jaeger, Zipkin",
        "",
        "## HLD vs LLD - Key Difference",
        "",
        "**High-Level Design (HLD)**:",
        "- General system design",
        "- Trade-offs between frameworks, components, databases",
        "- Choose best based on business needs",
        "- Both functional and non-functional aspects",
        "",
        "**Low-Level Design (LLD)**:",
        "- Translates HLD into specific details",
        "- Class diagrams, methods, data structures",
        "- Algorithms and implementation",
        "- How each part will be coded",
        "",
        "## Roadmap to Learn HLD",
        "",
        "### Phase 1: Basics",
        "- Understand HLD vs LLD difference",
        "- Learn goals of HLD",
        "- Study system architecture fundamentals",
        "",
        "### Phase 2: Core Components",
        "- Load Balancer",
        "- Content Delivery Network (CDN)",
        "- Caching strategies",
        "- API Gateway",
        "- Message Queues",
        "- Consistent Hashing",
        "- Communication Protocols",
        "- Network Protocols and Proxies",
        "",
        "### Phase 3: Design Principles",
        "- Scalability (horizontal and vertical)",
        "- Availability (uptime targets)",
        "- Consistency (strong vs eventual)",
        "- Reliability (error handling)",
        "- Fault Tolerance (graceful degradation)",
        "- CAP Theorem",
        "- Performance Optimization",
        "",
        "### Phase 4: Practice",
        "- Draw HLD diagrams",
        "- Design popular systems (Twitter, Netflix, Uber)",
        "- Interview preparation questions",
        "- Mock interviews",
        "",
        "## Interview Tips for HLD",
        "",
        "1. **Start with Requirements**: Clarify functional and non-functional",
        "2. **Draw Diagrams**: Visual > verbal explanations",
        "3. **Explain Trade-offs**: Why you chose X over Y",
        "4. **Scale Calculations**: Show back-of-envelope math",
        "5. **Component Selection**: Justify technology choices",
        "6. **Think Out Loud**: Show your thought process",
        "7. **Ask Questions**: Clarify constraints and scope"
      ],
      "keyPoints": [
        "HLD has 6 core components: Architecture, Modules, DFDs, Interfaces, Tech Stack, Deployment",
        "9 scalability concepts: Capacity, HTTP/HTTPS, WebSockets, Polling, SSE, Rate Limiting, Resiliency, Paging, Logging",
        "HLD focuses on WHAT and HOW (components), LLD on implementation details",
        "Always provide resiliency through replication, redundancy, and availability",
        "Draw diagrams, explain trade-offs, and justify technology choices"
      ]
    },
    {
      "id": "architecture-patterns",
      "title": "Architecture Patterns",
      "description": "Complete guide to modern system architectures",
      "content": [
        "Architecture patterns are proven solutions for organizing system components. Choosing the right architecture is critical for scalability, maintainability, and team productivity.",
        "",
        "## Why Architecture Patterns Matter",
        "",
        "**Impact on**:",
        "- **Scalability**: How easily can you handle 10x, 100x growth?",
        "- **Team Productivity**: Can multiple teams work independently?",
        "- **Deployment Speed**: How fast can you ship new features?",
        "- **Reliability**: What happens when components fail?",
        "- **Cost**: Infrastructure and operational expenses",
        "",
        "**Interview Importance**: Interviewers expect you to know when to use each pattern and justify your choices.",
        "",
        "## 1. Monolithic Architecture",
        "",
        "### What It Is",
        "Entire application built as a single, indivisible unit. All components share the same codebase, memory space, and database.",
        "",
        "### Key Characteristics",
        "- **Single Codebase**: All features in one repository",
        "- **Tight Coupling**: Components depend on each other directly",
        "- **Shared Memory**: No network calls between components",
        "- **Centralized Database**: Single database instance",
        "- **Layered Structure**: Presentation → Business Logic → Data Access",
        "- **All-or-Nothing Deployment**: Deploy entire application together",
        "",
        "### Components",
        "1. **User Interface (UI)**: Forms, buttons, user interactions",
        "2. **Application Logic**: Core business functionality",
        "3. **Data Access Layer**: Database interactions (CRUD operations)",
        "4. **Database**: Centralized data storage",
        "5. **External Dependencies**: Third-party APIs, services",
        "6. **Middleware**: Logging, security, monitoring",
        "",
        "### When to Use",
        "",
        "✅ **Best For**:",
        "- Small to medium applications",
        "- MVPs and prototypes",
        "- Teams < 10 developers",
        "- Simple business logic",
        "- Tight deadlines",
        "- Limited budget",
        "",
        "❌ **Avoid When**:",
        "- Application has 50+ features",
        "- Team > 20 developers",
        "- Need to scale specific features independently",
        "- Frequent deployments required",
        "- Different tech stacks needed for different modules",
        "",
        "### Pros and Cons",
        "",
        "**Advantages**:",
        "- Simple to develop and understand",
        "- Easy to test (single unit)",
        "- Straightforward deployment",
        "- Lower operational complexity",
        "- Better performance (no network overhead)",
        "- Easier debugging",
        "",
        "**Disadvantages**:",
        "- Hard to scale (must scale entire app)",
        "- Slow deployment (one change = full redeploy)",
        "- Single point of failure",
        "- Technology lock-in",
        "- Code becomes complex as app grows",
        "- Difficult for large teams",
        "",
        "### Migration Strategy",
        "",
        "**Strangler Fig Pattern**: Gradually replace monolith with microservices",
        "1. Identify module to extract",
        "2. Build new microservice",
        "3. Route traffic to new service",
        "4. Deprecate old module",
        "5. Repeat for other modules",
        "",
        "```mermaid",
        "flowchart TD",
        "    subgraph Monolith[Monolithic Application]",
        "        UI[Presentation Layer<br/>UI Components]",
        "        BL[Business Logic Layer<br/>Core Functionality]",
        "        DAL[Data Access Layer<br/>CRUD Operations]",
        "    end",
        "    ",
        "    UI --> BL",
        "    BL --> DAL",
        "    DAL --> DB[(Centralized<br/>Database)]",
        "    ",
        "    style Monolith fill:#1f2937",
        "    style UI fill:#3b82f6",
        "    style BL fill:#10b981",
        "    style DAL fill:#f59e0b",
        "    style DB fill:#8b5cf6",
        "```",
        "",
        "",
        "## 2. Microservices Architecture",
        "",
        "### What It Is",
        "Application designed as collection of small, independent services. Each service represents a single business capability.",
        "",
        "### How It Works",
        "- Each microservice handles specific functionality",
        "- Services communicate via APIs (HTTP, gRPC, message queues)",
        "- Different technologies can be used per service",
        "- Services deployed and scaled independently",
        "",
        "### Components",
        "1. **Microservices**: Small, focused services (e.g., User Service, Payment Service)",
        "2. **API Gateway**: Single entry point for clients, handles routing, auth, rate limiting",
        "3. **Service Registry**: Tracks service locations (Consul, Eureka)",
        "4. **Load Balancer**: Distributes traffic across service instances",
        "5. **Containerization**: Docker for packaging, Kubernetes for orchestration",
        "6. **Event Bus/Message Broker**: Kafka, RabbitMQ for async communication",
        "7. **Database per Service**: Each service owns its data",
        "8. **Caching**: Redis, Memcached for performance",
        "9. **Fault Tolerance**: Circuit breakers, retry mechanisms",
        "",
        "### 9 Microservices Design Patterns",
        "",
        "#### 1. API Gateway Pattern",
        "Single entry point hiding service complexity. Handles auth, logging, rate limiting.",
        "",
        "#### 2. Service Registry Pattern",
        "Phone book for services. Services register themselves, others look them up dynamically.",
        "",
        "#### 3. Circuit Breaker Pattern",
        "Prevents cascading failures. If service fails repeatedly, circuit trips and blocks requests temporarily.",
        "",
        "#### 4. Saga Pattern",
        "Manages distributed transactions across services. Breaks transaction into steps with compensating actions for rollback.",
        "",
        "#### 5. Event Sourcing Pattern",
        "Store all changes as events instead of current state. Reconstruct state by replaying events.",
        "",
        "#### 6. Strangler Pattern",
        "Gradually migrate from monolith. Build new features as microservices while old system remains.",
        "",
        "#### 7. Bulkhead Pattern",
        "Isolate services like ship compartments. Failure in one doesn't sink entire system.",
        "",
        "#### 8. API Composition Pattern",
        "Gather data from multiple services and combine into single response.",
        "",
        "#### 9. CQRS Pattern",
        "Separate read (Query) and write (Command) operations for optimization.",
        "",
        "### When to Use",
        "",
        "✅ **Best For**:",
        "- Large, complex applications",
        "- Teams > 20 developers",
        "- Need independent scaling",
        "- Frequent deployments",
        "- Different tech requirements per module",
        "- High availability requirements",
        "",
        "❌ **Avoid When**:",
        "- Small application",
        "- Limited resources",
        "- Team lacks distributed systems expertise",
        "- Simple business logic",
        "- Tight budget",
        "",
        "### Pros and Cons",
        "",
        "**Advantages**:",
        "- Independent scaling",
        "- Technology flexibility",
        "- Faster deployments",
        "- Fault isolation",
        "- Team autonomy",
        "- Easier to understand individual services",
        "",
        "**Disadvantages**:",
        "- Complex infrastructure",
        "- Network latency",
        "- Distributed debugging is hard",
        "- Data consistency challenges",
        "- Higher operational cost",
        "- Requires DevOps expertise",
        "",
        "### Real-World Examples",
        "- **Netflix**: 700+ microservices",
        "- **Uber**: Service-oriented architecture",
        "- **Amazon**: Thousands of services",
        "",
        "```mermaid",
        "flowchart TD",
        "    Client[Client Apps<br/>Web/Mobile]",
        "    ",
        "    Client --> API[API Gateway<br/>Routing • Auth • Rate Limiting]",
        "    ",
        "    API --> US[User Service]",
        "    API --> OS[Order Service]",
        "    API --> PS[Payment Service]",
        "    API --> NS[Notification Service]",
        "    ",
        "    US --> DB1[(User DB)]",
        "    OS --> DB2[(Order DB)]",
        "    PS --> DB3[(Payment DB)]",
        "    NS --> DB4[(Notif DB)]",
        "    ",
        "    MQ[Message Queue<br/>Kafka/RabbitMQ]",
        "    ",
        "    US -.Publish.-> MQ",
        "    OS -.Publish.-> MQ",
        "    PS -.Publish.-> MQ",
        "    MQ -.Subscribe.-> NS",
        "    ",
        "    style API fill:#10b981",
        "    style US fill:#3b82f6",
        "    style OS fill:#3b82f6",
        "    style PS fill:#3b82f6",
        "    style NS fill:#3b82f6",
        "    style MQ fill:#8b5cf6",
        "```",
        "",
        "",
        "## 3. Monolithic vs Microservices Comparison",
        "",
        "| Aspect | Monolithic | Microservices |",
        "|--------|-----------|---------------|",
        "| **Deployment** | All-or-nothing | Independent per service |",
        "| **Scaling** | Scale entire app | Scale specific services |",
        "| **Development** | Single team | Multiple teams |",
        "| **Technology** | One stack | Multiple stacks |",
        "| **Database** | Shared | Database per service |",
        "| **Communication** | Method calls | API calls (network) |",
        "| **Testing** | Easier (single unit) | Complex (integration tests) |",
        "| **Debugging** | Straightforward | Distributed tracing needed |",
        "| **Initial Cost** | Lower | Higher |",
        "| **Failure Impact** | Entire app down | Isolated to service |",
        "| **Team Size** | < 10 ideal | > 20 ideal |",
        "| **Best For** | MVPs, simple apps | Complex, large apps |",
        "",
        "## 4. Event-Driven Architecture (EDA)",
        "",
        "### What It Is",
        "System where components communicate by producing and consuming events. Events represent significant occurrences or state changes.",
        "",
        "### Importance",
        "- **Flexibility**: System adapts to changes dynamically",
        "- **Scalability**: Add/remove components without affecting others",
        "- **Real-Time Processing**: Events handled as they occur",
        "- **Decentralized Communication**: No direct dependencies",
        "",
        "### Components",
        "1. **Event Source**: Generates events (UI, sensors, databases)",
        "2. **Event**: Message representing something that happened",
        "3. **Event Broker/Bus**: Central hub (Kafka, RabbitMQ, AWS EventBridge)",
        "4. **Publisher**: Sends events to broker",
        "5. **Subscriber**: Listens for events and reacts",
        "6. **Event Handler**: Code that processes events",
        "7. **Dispatcher**: Routes events to handlers",
        "8. **Aggregator**: Combines related events",
        "",
        "### How It Works",
        "1. Event source generates event (e.g., \"OrderPlaced\")",
        "2. Publisher sends event to broker with topic/channel",
        "3. Broker stores and routes event",
        "4. Subscribers receive event if they're subscribed to topic",
        "5. Event handlers process event asynchronously",
        "",
        "### Event Types",
        "- **UserLoggedIn**: Authentication event",
        "- **OrderPlaced**: E-commerce event",
        "- **PaymentReceived**: Payment event",
        "- **InventoryUpdated**: Stock event",
        "",
        "### When to Use",
        "",
        "✅ **Best For**:",
        "- Real-time systems (stock trading, gaming)",
        "- IoT applications",
        "- E-commerce (order processing)",
        "- Notification systems",
        "- Audit logging",
        "- Systems requiring high decoupling",
        "",
        "❌ **Avoid When**:",
        "- Simple CRUD applications",
        "- Immediate consistency required",
        "- Debugging complexity is a concern",
        "",
        "### Pros and Cons",
        "",
        "**Advantages**:",
        "- Loose coupling between components",
        "- Real-time responsiveness",
        "- Easy to add new subscribers",
        "- Natural fit for async workflows",
        "- Scalable",
        "",
        "**Disadvantages**:",
        "- Debugging is complex",
        "- Event ordering challenges",
        "- Eventual consistency",
        "- Harder to test",
        "- Potential for duplicate events",
        "",
        "### Real-World Example",
        "**E-Commerce Platform**:",
        "- User places order → \"OrderPlaced\" event",
        "- Inventory service subscribes → Updates stock",
        "- Payment service subscribes → Processes payment",
        "- Notification service subscribes → Sends email",
        "- Analytics service subscribes → Records metrics",
        "",
        "```mermaid",
        "flowchart LR",
        "    subgraph Publishers",
        "        P1[UI App]",
        "        P2[API Service]",
        "        P3[IoT Sensor]",
        "    end",
        "    ",
        "    EB[Event Bus/Broker<br/>Kafka • RabbitMQ • AWS EventBridge]",
        "    ",
        "    subgraph Subscribers",
        "        S1[Analytics Service]",
        "        S2[Email Service]",
        "        S3[Inventory Service]",
        "        S4[Notification Service]",
        "    end",
        "    ",
        "    P1 -->|OrderPlaced| EB",
        "    P2 -->|UserLoggedIn| EB",
        "    P3 -->|InventoryUpdated| EB",
        "    ",
        "    EB -->|Subscribe| S1",
        "    EB -->|Subscribe| S2",
        "    EB -->|Subscribe| S3",
        "    EB -->|Subscribe| S4",
        "    ",
        "    style EB fill:#8b5cf6",
        "    style P1 fill:#3b82f6",
        "    style P2 fill:#3b82f6",
        "    style P3 fill:#3b82f6",
        "    style S1 fill:#10b981",
        "    style S2 fill:#10b981",
        "    style S3 fill:#10b981",
        "    style S4 fill:#10b981",
        "```",
        "",
        "",
        "## 5. Serverless Architecture",
        "",
        "### What It Is",
        "Build and run applications without managing servers. Cloud provider handles infrastructure, scaling, and availability.",
        "",
        "### Key Concept",
        "You write functions, cloud provider runs them on-demand. Pay only for execution time.",
        "",
        "### Providers and Platforms",
        "- **AWS Lambda**: Most popular, integrates with 200+ AWS services",
        "- **Azure Functions**: Microsoft's offering, multi-language support",
        "- **Google Cloud Functions**: Google's serverless platform",
        "- **Oracle Cloud Functions**: Enterprise-focused",
        "",
        "### How It Works",
        "1. Write function (e.g., resize image)",
        "2. Deploy to cloud provider",
        "3. Configure trigger (HTTP request, file upload, schedule)",
        "4. Provider runs function when triggered",
        "5. Auto-scales based on demand",
        "6. Pay per execution",
        "",
        "### Design Patterns",
        "1. **Function-as-a-Service (FaaS)**: Single-purpose functions",
        "2. **Backend-for-Frontend (BFF)**: Serverless API layer",
        "3. **Event-Driven**: Functions triggered by events",
        "4. **Scheduled Tasks**: Cron jobs",
        "",
        "### When to Use",
        "",
        "✅ **Best For**:",
        "- Variable/unpredictable workloads",
        "- Event-driven tasks",
        "- Microservices backends",
        "- Data processing pipelines",
        "- Scheduled jobs",
        "- Prototypes and MVPs",
        "",
        "❌ **Avoid When**:",
        "- Long-running processes (> 15 min)",
        "- Consistent high traffic (more expensive)",
        "- Need fine-grained server control",
        "- Low-latency requirements (cold starts)",
        "",
        "### Pros and Cons",
        "",
        "**Advantages**:",
        "- No server management",
        "- Auto-scaling",
        "- Pay-per-use pricing",
        "- Fast development",
        "- Built-in high availability",
        "- Focus on code, not infrastructure",
        "",
        "**Disadvantages**:",
        "- Cold start latency",
        "- Vendor lock-in",
        "- Debugging limitations",
        "- Execution time limits",
        "- Stateless (no local storage)",
        "- Potentially higher cost at scale",
        "",
        "```mermaid",
        "flowchart TD",
        "    Trigger[Triggers]",
        "    ",
        "    Trigger --> HTTP[HTTP Request]",
        "    Trigger --> Upload[File Upload]",
        "    Trigger --> Schedule[Scheduled Event]",
        "    Trigger --> Queue[Message Queue]",
        "    ",
        "    HTTP --> Lambda1[Lambda Function<br/>Image Resize]",
        "    Upload --> Lambda2[Lambda Function<br/>Process Video]",
        "    Schedule --> Lambda3[Lambda Function<br/>Daily Report]",
        "    Queue --> Lambda4[Lambda Function<br/>Send Email]",
        "    ",
        "    Lambda1 --> S3[(S3 Storage)]",
        "    Lambda2 --> S3",
        "   Lambda3 --> DB[(DynamoDB)]",
        "    Lambda4 --> SES[AWS SES]",
        "    ",
        "    style Trigger fill:#1f2937",
        "    style Lambda1 fill:#10b981",
        "    style Lambda2 fill:#10b981",
        "    style Lambda3 fill:#10b981",
        "    style Lambda4 fill:#10b981",
        "    style S3 fill:#f59e0b",
        "    style DB fill:#8b5cf6",
        "```",
        "",
        "",
        "## 6. Stateful vs Stateless Architecture",
        "",
        "### Stateful Architecture",
        "",
        "**Definition**: Server maintains client session information across requests.",
        "",
        "**Characteristics**:",
        "- Session data stored in server memory/database",
        "- Server remembers previous interactions",
        "- Client doesn't need to send full context each time",
        "",
        "**Example**: Traditional web apps with server-side sessions, shopping cart data stored on server.",
        "",
        "**Pros**:",
        "- Richer user experience",
        "- Less data transferred per request",
        "- Server has full context",
        "",
        "**Cons**:",
        "- Harder to scale (session synchronization)",
        "- Server failure loses sessions",
        "- Requires sticky sessions or shared session store",
        "",
        "### Stateless Architecture",
        "",
        "**Definition**: Server doesn't store client session information. Each request is independent.",
        "",
        "**Characteristics**:",
        "- Each request contains all necessary information",
        "- Server doesn't remember previous requests",
        "- Session data stored client-side (JWT, cookies)",
        "",
        "**Example**: RESTful APIs where each request has auth token and required data.",
        "",
        "**Pros**:",
        "- Easy horizontal scaling",
        "- Better fault tolerance",
        "- Faster response times",
        "- Simpler load balancing",
        "- Lower resource usage",
        "",
        "**Cons**:",
        "- More data per request",
        "- Client manages session",
        "- Potentially less secure if not implemented correctly",
        "",
        "### Comparison Table",
        "",
        "| Aspect | Stateful | Stateless |",
        "|--------|----------|----------|",
        "| **Scalability** | Complex (session sync) | Simple (horizontal) |",
        "| **Fault Tolerance** | Failures affect sessions | Isolated failures |",
        "| **Performance** | May have latency | Faster responses |",
        "| **Resource Usage** | Higher (session storage) | Lower |",
        "| **Caching** | Complex | Simplified |",
        "| **Deployment** | More complex | Easier |",
        "| **Load Balancing** | Needs session affinity | Simple |",
        "| **Development** | Manage session issues | Focus on business logic |",
        "",
        "### When to Use",
        "",
        "**Use Stateful When**:",
        "- Real-time applications (gaming, chat)",
        "- Complex multi-step workflows",
        "- Rich user sessions needed",
        "",
        "**Use Stateless When**:",
        "- RESTful APIs",
        "- Microservices",
        "- High-scale applications",
        "- Cloud-native apps",
        "",
        "## 7. Pub/Sub Architecture",
        "",
        "### What It Is",
        "Publish-Subscribe pattern where publishers send messages to topics without knowing subscribers. Subscribers receive messages from topics they're interested in.",
        "",
        "### Components",
        "1. **Publisher**: Creates and sends messages (doesn't know subscribers)",
        "2. **Subscriber**: Receives messages from topics (doesn't know publishers)",
        "3. **Topic**: Named channel categorizing messages",
        "4. **Message Broker**: Routes messages (Google Pub/Sub, Apache Kafka, AWS SNS)",
        "5. **Message**: Data unit (text, JSON, binary)",
        "6. **Subscription**: Links subscriber to topic",
        "",
        "### How It Works",
        "1. Publisher creates message and sends to topic",
        "2. System sorts message into topic/channel",
        "3. Subscribers register interest in topics",
        "4. Message broker receives message",
        "5. Broker routes to all subscribed subscribers",
        "6. Asynchronous delivery (decoupled)",
        "",
        "### Types of Pub/Sub Services",
        "",
        "**1. Full Pub/Sub Service**:",
        "- Global messaging with auto-scaling",
        "- At-least-once delivery",
        "- High throughput",
        "",
        "**2. Pub/Sub Lite**:",
        "- Zonal/regional messaging",
        "- Lower cost",
        "- Predictable capacity",
        "",
        "### Real-World Example: Twitter",
        "- **Publishers**: Users posting tweets",
        "- **Subscribers**: Followers",
        "- **Topics**: Each user's tweets",
        "- **Message Broker**: Twitter backend",
        "- **Messages**: Individual tweets",
        "",
        "Followers receive tweets in real-time without direct connection to publisher.",
        "",
        "### When to Use",
        "",
        "✅ **Use When**:",
        "- Real-time messaging",
        "- Event-driven systems",
        "- Fanout scenarios (1 message → many receivers)",
        "- Decoupled architectures",
        "- Async communication needed",
        "- Analytics and logging",
        "",
        "❌ **Avoid When**:",
        "- Point-to-point communication sufficient",
        "- Ordered processing critical",
        "- Simple request-response needed",
        "- Low-latency requirements",
        "",
        "### Pros and Cons",
        "",
        "**Advantages**:",
        "- Complete decoupling",
        "- Scalable (add subscribers easily)",
        "- Real-time delivery",
        "- Multiple consumers",
        "- Reliability (message persistence)",
        "- Asynchronous",
        "",
        "**Disadvantages**:",
        "- Complexity",
        "- Message ordering challenges",
        "- Potential for duplicate messages",
        "- Debugging difficulty",
        "- Network dependency",
        "",
        "### Pub/Sub vs Point-to-Point",
        "",
        "| Feature | Pub/Sub | Point-to-Point |",
        "|---------|---------|----------------|",
        "| **Receivers** | Multiple | Single |",
        "| **Coupling** | Loose | Tight |",
        "| **Scalability** | High | Limited |",
        "| **Use Case** | Broadcasting | Direct messaging |",
        "",
        "```mermaid",
        "flowchart TB",
        "    subgraph Publishers",
        "        P1[Publisher A<br/>User Service]",
        "        P2[Publisher B<br/>Order Service]",
        "        P3[Publisher C<br/>Payment Service]",
        "    end",
        "    ",
        "    subgraph Broker[Message Broker]",
        "        T1[Topic: user-events]",
        "        T2[Topic: order-events]",
        "        T3[Topic: payment-events]",
        "    end",
        "    ",
        "    subgraph Subscribers",
        "        S1[Analytics<br/>Service]",
        "        S2[Notification<br/>Service]",
        "        S3[Reporting<br/>Service]",
        "        S4[Audit<br/>Service]",
        "    end",
        "    ",
        "    P1 --> T1",
        "    P2 --> T2",
        "    P3 --> T3",
        "    ",
        "    T1 --> S1",
        "    T1 --> S2",
        "    T2 --> S1",
        "    T2 --> S2",
        "    T2 --> S3",
        "    T3 --> S2",
        "    T3 --> S4",
        "    ",
        "    style T1 fill:#3b82f6",
        "    style T2 fill:#10b981",
        "    style T3 fill:#f59e0b",
        "    style Broker fill:#1f2937",
        "```",
        "",
        "",
        "## Decision Matrix: Choosing the Right Architecture",
        "",
        "### Quick Decision Tree",
        "",
        "**Starting a new project?**",
        "- Small team (< 10), simple app → **Monolithic**",
        "- Large team (> 20), complex app → **Microservices**",
        "",
        "**Need real-time features?**",
        "- User-facing real-time → **Event-Driven** + **WebSockets**",
        "- Backend async processing → **Pub/Sub**",
        "",
        "**Variable workload?**",
        "- Unpredictable spikes → **Serverless**",
        "- Consistent traffic → **Traditional servers**",
        "",
        "**Session requirements?**",
        "- Need server-side sessions → **Stateful**",
        "- RESTful API → **Stateless**",
        "",
        "### Comparison: All Architecture Patterns",
        "",
        "| Pattern | Complexity | Scalability | Cost | Best For |",
        "|---------|-----------|-------------|------|----------|",
        "| **Monolithic** | Low | Low | Low | MVPs, small apps |",
        "| **Microservices** | High | High | High | Large, complex apps |",
        "| **Event-Driven** | Medium-High | High | Medium | Real-time systems |",
        "| **Serverless** | Low-Medium | Auto | Variable | Variable workloads |",
        "| **Stateless** | Low | High | Low | APIs, cloud apps |",
        "| **Pub/Sub** | Medium | High | Medium | Broadcasting, analytics |",
        "",
        "### Hybrid Approaches",
        "",
        "Most real systems combine patterns:",
        "",
        "**Example: Modern E-Commerce**",
        "- **Core Services**: Microservices (User, Product, Order)",
        "- **Real-Time Features**: Event-Driven (inventory updates)",
        "- **Background Jobs**: Serverless (image processing, emails)",
        "- **APIs**: Stateless (mobile apps, web clients)",
        "- **Notifications**: Pub/Sub (order updates, promotions)",
        "",
        "## Interview Tips",
        "",
        "### What Interviewers Expect",
        "",
        "1. **Know Trade-offs**: Explain pros/cons of each pattern",
        "2. **Real-World Context**: Mention companies using patterns",
        "3. **Decision Justification**: Why architecture X over Y for this problem?",
        "4. **Scalability Discussion**: How does each pattern scale?",
        "5. **Migration Strategies**: How to evolve from one to another?",
        "",
        "### Common Interview Questions",
        "",
        "**Q: When would you use microservices over monolithic?**",
        "A: Large team (> 20), need independent scaling, different tech stacks, frequent deployments.",
        "",
        "**Q: What's the main challenge with microservices?**",
        "A: Distributed debugging, data consistency, network latency, operational complexity.",
        "",
        "**Q: When is serverless a bad choice?**",
        "A: Long-running processes, consistent high traffic (cost), low-latency requirements.",
        "",
        "**Q: What's the difference between event-driven and pub/sub?**",
        "A: Event-driven is the broader pattern. Pub/Sub is a specific implementation mechanism.",
        "",
        "### Framework for Answering",
        "",
        "1. **Clarify Requirements**: \"What's the expected scale? Team size?\"",
        "2. **State Assumptions**: \"Assuming we have 100 engineers...\"",
        "3. **Propose Architecture**: \"I'd use microservices because...\"",
        "4. **Explain Trade-offs**: \"This gives us X, but costs Y\"",
        "5. **Discuss Alternatives**: \"Alternatively, we could use monolith if...\""
      ],
      "keyPoints": [
        "7 patterns: Monolithic, Microservices, Event-Driven, Serverless, Stateful/Stateless, Pub/Sub",
        "Monolithic: Simple, low cost, best for small teams and MVPs",
        "Microservices: Independent scaling, 9 design patterns, best for large teams",
        "Event-Driven: Real-time, decoupled, best for async workflows",
        "Serverless: No servers, pay-per-use, auto-scaling",
        "Stateless: Easy scaling, Stateful: Rich sessions",
        "Pub/Sub: Broadcasting, 1-to-many messaging",
        "Most systems use hybrid approaches combining multiple patterns"
      ]
    },
    {
      "id": "fundamentals",
      "title": "System Design Fundamentals",
      "description": "Core concepts every engineer must know",
      "content": [
        "Before diving into specific designs, master these fundamental concepts that appear in every system design interview.",
        "",
        "## Key Concepts",
        "",
        "**Scalability**",
        "- Vertical Scaling: Add more power to existing machines",
        "- Horizontal Scaling: Add more machines to the pool",
        "- When to use each: Vertical is simpler but has limits",
        "",
        "```mermaid",
        "flowchart TD",
        "    Scale[Need to Scale?]",
        "    ",
        "    Scale --> Vertical[Vertical Scaling<br/>Add more RAM/CPU<br/>to existing server]",
        "    Scale --> Horizontal[Horizontal Scaling<br/>Add more servers]",
        "    ",
        "    Vertical --> VPros[✅ Simple<br/>✅ No code changes<br/>❌ Hardware limits<br/>❌ Single point of failure]",
        "    ",
        "    Horizontal --> HPros[✅ Nearly unlimited<br/>✅ Better fault tolerance<br/>❌ More complex<br/>❌ Need load balancer]",
        "    ",
        "    style Scale fill:#f59e0b",
        "    style Vertical fill:#3b82f6",
        "    style Horizontal fill:#10b981",
        "```",
        "",
        "",
        "**Latency vs Throughput**",
        "- Latency: Time to complete a request",
        "- Throughput: Requests handled per unit time",
        "- Often trade one for the other",
        "",
        "**CAP Theorem**",
        "In a distributed system, you can only guarantee two of:",
        "- **Consistency**: All nodes see same data simultaneously",
        "- **Availability**: System responds to all requests",
        "- **Partition Tolerance**: System works despite network failures",
        "",
        "```mermaid",
        "graph TB",
        "    subgraph cap[CAP Theorem - Choose 2 of 3]",
        "        C[Consistency<br/>All nodes see<br/>same data]",
        "        A[Availability<br/>System always<br/>responds]",
        "        P[Partition Tolerance<br/>Works despite<br/>network failures]",
        "    end",
        "    ",
        "    CA[CA Systems<br/>RDBMS • Single Node<br/>PostgreSQL]",
        "    CP[CP Systems<br/>MongoDB • HBase<br/>Redis]",
        "    AP[AP Systems<br/>Cassandra • DynamoDB<br/>Riak]",
        "    ",
        "    C -.-> CA",
        "    A -.-> CA",
        "    C -.-> CP",
        "    P -.-> CP",
        "    A -.-> AP",
        "    P -.-> AP",
        "    ",
        "    style C fill:#10b981",
        "    style A fill:#3b82f6",
        "    style P fill:#f59e0b",
        "    style CA fill:#374151",
        "    style CP fill:#374151",
        "    style AP fill:#374151",
        "    style cap fill:#1f2937",
        "```",
        "",
        "",
        "**Consistency Patterns**",
        "- Strong Consistency: Reads always return latest write",
        "- Eventual Consistency: Reads may return stale data temporarily",
        "- Weak Consistency: No guarantees",
        "",
        "## Availability Patterns",
        "**Failover Strategies**",
        "- **Active-Passive (Master-Slave)**: Heartbeats between active and passive. If active dies, passive takes over. Downtime during switch.",
        "- **Active-Active (Master-Master)**: Both handle traffic. Complex synchronization required.",
        "",
        "## Proxies",
        "Intermediary between client and server.",
        "- **Forward Proxy**: Client side. Hides client ID, bypasses restrictions.",
        "- **Reverse Proxy**: Server side. Hides server ID, Load balancing, SSL termination, Caching.",
        "",
        "## Architecture Patterns",
        "**Core Structures**",
        "- **Client-Server**: Basic request-response model.",
        "- **Monolith**: Single unified codebase. Simple to deploy, hard to scale components independently.",
        "- **Microservices**: Small, independent services communicating via APIs. Complex to manage, easy to scale independently."
      ],
      "keyPoints": [
        "Start with requirements gathering",
        "Calculate scale: users, requests, data",
        "Design high-level first, then detail",
        "Discuss tradeoffs openly"
      ],
      "diagrams": [
        {
          "url": "/diagrams/cap-theorem.png",
          "caption": "CAP Theorem Visualization",
          "alt": "Venn diagram showing the three properties of CAP theorem and their intersections"
        }
      ]
    },
    {
      "id": "building-blocks",
      "title": "Building Blocks",
      "description": "Essential components for distributed systems",
      "content": [
        "These are the Lego blocks of system design. Understanding when and how to use each is crucial.",
        "",
        "## Load Balancer",
        "",
        "```mermaid",
        "flowchart TD",
        "    Client[Client Requests]",
        "    ",
        "    Client --> LB[Load Balancer<br/>Round Robin • Least Connections]",
        "    ",
        "    LB -->|Request 1| S1[Server 1<br/>Active]",
        "    LB -->|Request 2| S2[Server 2<br/>Active]",
        "    LB -->|Request 3| S3[Server 3<br/>Active]",
        "    ",
        "    S1 --> Cache[(Redis Cache)]",
        "    S2 --> Cache",
        "    S3 --> Cache",
        "    ",
        "    S1 --> DB[(Database<br/>Master)]",
        "    S2 --> DB",
        "    S3 --> DB",
        "    ",
        "    style LB fill:#10b981",
        "    style S1 fill:#3b82f6",
        "    style S2 fill:#3b82f6",
        "    style S3 fill:#3b82f6",
        "    style Cache fill:#f59e0b",
        "    style DB fill:#8b5cf6",
        "```",
        "s",
        "Distribute traffic across servers",
        "- Layer 4 (TCP) vs Layer 7 (HTTP)",
        "- Algorithms: Round Robin, Least Connections, IP Hash",
        "- Health checks and failover",
        "",
        "## Caching",
        "",
        "```mermaid",
        "flowchart TD",
        "    Client[Client Request]",
        "    ",
        "    Client --> App[Application Server]",
        "    App --> CheckCache{Cache Hit?}",
        "    ",
        "    CheckCache -->|Yes| ReturnCache[Return from Cache<br/>Fast Response]",
        "    CheckCache -->|No| DB[(Database)]",
        "    ",
        "    DB --> UpdateCache[Update Cache]",
        "    UpdateCache --> ReturnDB[Return from DB<br/>Slower Response]",
        "    ",
        "    ReturnCache --> Client",
        "    ReturnDB --> Client",
        "    ",
        "    style CheckCache fill:#f59e0b",
        "    style ReturnCache fill:#10b981",
        "    style UpdateCache fill:#3b82f6",
        "    style DB fill:#8b5cf6",
        "```",
        "",
        "Store frequently accessed data in memory",
        "- Client-side, CDN, Application, Database caching",
        "- Write-through vs Write-behind vs Write-around",
        "- Cache invalidation strategies",
        "- Redis, Memcached",
        "",
        "## Databases",
        "**SQL (Relational)**",
        "- ACID guarantees",
        "- Complex queries, joins",
        "- MySQL, PostgreSQL",
        "",
        "**NoSQL**",
        "- Document: MongoDB, Couchbase",
        "- Key-Value: Redis, DynamoDB",
        "- Wide-Column: Cassandra, HBase",
        "- Graph: Neo4j",
        "",
        "## Message Queues",
        "Async communication between services",
        "- Kafka, RabbitMQ, SQS",
        "- Pub/Sub patterns",
        "- Event-driven architecture",
        "",
        "## CDN (Content Delivery Network)",
        "Distribute static content globally",
        "- Reduce latency",
        "- Offload origin servers",
        "- CloudFlare, CloudFront, Akamai",
        "",
        "## Communication Protocols",
        "- **REST**: Resource-based, standard HTTP verbs. Simple, stateless.",
        "- **GraphQL**: Flexible queries, client asks for exactly what it needs. Single endpoint.",
        "- **WebSockets**: Full-duplex communication for real-time apps (chat, gaming).",
        "- **gRPC**: High performance RPC framework using Protobufs.",
        "",
        "## API Gateway",
        "",
        "```mermaid",
        "flowchart TD",
        "    Mobile[Mobile App]",
        "    Web[Web App]",
        "    ",
        "    Mobile --> Gateway[API Gateway<br/>• Authentication<br/>• Rate Limiting<br/>• Routing<br/>• Caching]",
        "    Web --> Gateway",
        "    ",
        "    Gateway --> Auth[Auth Service]",
        "    Gateway --> User[User Service]",
        "    Gateway --> Product[Product Service]",
        "    Gateway --> Order[Order Service]",
        "    Gateway --> Payment[Payment Service]",
        "    ",
        "    style Gateway fill:#10b981",
        "    style Auth fill:#f59e0b",
        "    style User fill:#3b82f6",
        "    style Product fill:#3b82f6",
        "    style Order fill:#3b82f6",
        "    style Payment fill:#3b82f6",
        "```",
        "",
        "Single entry point for all clients.",
        "- Request Routing",
        "- Authentication & Authorization",
        "- Rate Limiting",
        "- SSL Termination"
      ],
      "keyPoints": [
        "Cache everything that can be cached",
        "Use CDN for static assets",
        "Choose database based on access patterns",
        "Message queues for decoupling services"
      ],
      "diagrams": [
        {
          "url": "/diagrams/system-architecture.png",
          "caption": "Typical System Architecture",
          "alt": "Diagram showing load balancer, application servers, cache, database, and CDN"
        }
      ]
    },
    {
      "id": "reliability-security",
      "title": "Reliability & Security",
      "description": "Ensuring system stability and safety",
      "content": [
        "Building a system is half the battle; keeping it running securely is the other half.",
        "",
        "## Reliability Patterns",
        "**Fault Tolerance**",
        "- **Circuit Breaker**: Detect failures and stop sending requests to failing service to prevent cascading failure.",
        "- **Redundancy**: Eliminate single points of failure (SPoF) by duplicating components.",
        "- **Bulkhead**: Isolate components so failure in one doesn't bring down others.",
        "",
        "**Traffic Management**",
        "- **Rate Limiting**: Restrict number of requests from a user/IP to prevent abuse.",
        "- **Throttling**: Degrade service quality gracefully when under load.",
        "",
        "## Observability",
        "- **Logging**: Record discrete events (what happened).",
        "- **Metrics**: Aggregated numerical data (resource usage, error rates).",
        "- **Tracing**: Follow a request's journey through distributed services.",
        "",
        "## Security",
        "- **Authentication (AuthN)**: Verifying identity (Who are you?).",
        "- **Authorization (AuthZ)**: Verifying permissions (What can you do?).",
        "- **Encryption**: TLS/SSL for data in transit, AES for data at rest."
      ],
      "keyPoints": [
        "Design for failure - assume things will break",
        "Security is not an afterthought",
        "Observability is crucial for debugging production",
        "Protect your downstream services"
      ]
    },
    {
      "id": "design-process",
      "title": "The Design Process",
      "description": "A structured approach to system design interviews",
      "content": [
        "Follow this framework to systematically approach any system design question.",
        "",
        "## Step 1: Requirements Clarification (3-5 min)",
        "Ask questions to understand scope",
        "- Functional requirements: What should the system do?",
        "- Non-functional requirements: Scale, latency, availability",
        "- Constraints: Budget, timeline, existing systems",
        "",
        "## Step 2: Capacity Estimation (3-5 min)",
        "Back-of-envelope calculations",
        "- Daily/Monthly active users",
        "- Requests per second (RPS)",
        "- Storage requirements",
        "- Bandwidth needs",
        "",
        "## Step 3: High-Level Design (10-15 min)",
        "Draw the main components",
        "- Clients",
        "- Load balancers",
        "- Application servers",
        "- Databases",
        "- Caches",
        "- External services",
        "",
        "## Step 4: Detailed Design (15-20 min)",
        "Dive deep into critical components",
        "- Database schema",
        "- API design",
        "- Algorithm choices",
        "- Scaling strategies",
        "",
        "## Step 5: Tradeoffs & Bottlenecks (5-10 min)",
        "Discuss limitations and alternatives",
        "- What could fail?",
        "- How to handle failures?",
        "- What would you change at 10x scale?"
      ],
      "keyPoints": [
        "Always start with requirements",
        "Calculate scale before designing",
        "Draw diagrams as you explain",
        "Discuss tradeoffs proactively"
      ],
      "examples": [
        {
          "title": "Capacity Estimation Example: URL Shortener",
          "explanation": "**Traffic**\n- 100M new URLs/month = ~40 URLs/second\n- Read:Write ratio 100:1 = 4000 reads/second\n\n**Storage**\n- Each URL: 500 bytes\n- 100M × 500 bytes = 50GB/month\n- 5 years = 3TB storage\n\n**Bandwidth**\n- Writes: 40 × 500 bytes = 20KB/s\n- Reads: 4000 × 500 bytes = 2MB/s"
        }
      ]
    },
    {
      "id": "common-designs",
      "title": "Common System Designs",
      "description": "Practice these frequently asked systems",
      "content": [
        "These systems appear most frequently in interviews. Understanding their key challenges prepares you for variations.",
        "",
        "## URL Shortener (Easy)",
        "Key challenges:",
        "- Unique ID generation",
        "- Handling collisions",
        "- Caching popular URLs",
        "",
        "**Solution**",
        "- **Database**: Key-Value Store (DynamoDB or Riak) for fast read/write.",
        "- **ID Generation**: Base62 conversion of a distributed ID (Twitter Snowflake) or pre-generated keys (KGS).",
        "- **Caching**: Memcached/Redis for redirects. LRU eviction policy.",
        "",
        "## Rate Limiter (Medium)",
        "Key challenges:",
        "- Algorithm choice (Token bucket, Sliding window)",
        "- Distributed rate limiting",
        "- Race conditions",
        "",
        "**Solution**",
        "- **Architecture**: Placed at API Gateway or as Sidecar (Envoy).",
        "- **Storage**: Redis to hold counters/timestamps with TTL.",
        "- **Algorithm**:",
        "- **Token Bucket**: Allows bursts, easy to implement.",
        "- **Sliding Window Log**: Very accurate, higher memory usage.",
        "",
        "## Twitter/Social Feed (Medium)",
        "Key challenges:",
        "- Fan-out on write vs fan-out on read",
        "- Hot celebrities problem",
        "- Real-time updates",
        "",
        "**Solution**",
        "- **Hybrid Approach**: ",
        "  - **Push (Fan-out on Write)**: Pre-compute feeds for normal users. Fast reads.",
        "  - **Pull (Fan-out on Read)**: Fetch tweets for celebrities at read time. Avoids writing millions of entries.",
        "- **Storage**: User Graph in GraphDB (Neo4j), Tweets in Cassandra/DynamoDB.",
        "",
        "## Dropbox / File Storage (Medium)",
        "Key challenges:",
        "- File synchronization",
        "- Conflict resolution",
        "- Efficient storage and deduplication",
        "",
        "**Solution**",
        "- **Storage**: Blob storage (S3) for chunks. Metadata in SQL (PostgreSQL) for file hierarchy.",
        "- **Sync**: Chunking algorithm (breaks files into 4MB chunks). Only upload changed chunks.",
        "- **Deduplication**: Hash-based (SHA-256). Store identical chunks once.",
        "- **Conflict**: Last-write-wins or version history. Notification for conflicts.",
        "- **Architecture**: Client → Sync Service → Metadata DB + Block Storage.",
        "",
        "## Instagram / Photo Sharing (Medium)",
        "Key challenges:",
        "- Image storage and CDN",
        "- Feed generation",
        "- Follow/Unfollow at scale",
        "",
        "**Solution**",
        "- **Storage**: ",
        "  - Images in S3 + CDN (CloudFront).",
        "  - Metadata (likes, comments) in Cassandra (wide-column).",
        "  - User graph in Graph DB or denormalized SQL.",
        "- **Feed**: Hybrid approach (pre-compute for active users, pull for inactive).",
        "- **Image Processing**: Upload → Resize to multiple formats → Store in S3 → Push to CDN.",
        "- **Scale**: Partition by UserID. Caching layer for hot users.",
        "",
        "## WhatsApp / Messaging (Hard)",
        "Key challenges:",
        "- Real-time message delivery",
        "- End-to-end encryption",
        "- Offline message storage",
        "",
        "**Solution**",
        "- **Protocol**: WebSocket for persistent connections.",
        "- **Message Queue**: Kafka for message buffering. Guarantees delivery when user comes online.",
        "- **Database**: ",
        "  - Messages in Cassandra (partitioned by UserID).",
        "  - User status in Redis (online/offline).",
        "- **Encryption**: E2E encryption (Signal Protocol). Server stores encrypted blobs.",
        "- **Read Receipts**: Separate acknowledgment system. Double checkmark on delivery.",
        "- **Group Chat**: Fan-out to all members. Limit group size (256 users).",
        "",
        "## Facebook Messenger (Hard)",
        "Key challenges:",
        "- Real-time messaging",
        "- Group chats",
        "- Media sharing",
        "",
        "**Solution**",
        "- **Architecture**: ",
        "  - Chat Service (WebSocket connections).",
        "  - Message Service (stores messages).",
        "  - Presence Service (online status).",
        "- **Storage**: HBase for messages (optimized for sequential writes).",
        "- **Group Chat**: Each message copied to all members' inboxes (fan-out).",
        "- **Optimization**: Message batching. Compress messages.",
        "- **Media**: Upload to blob storage first, share URL in message.",
        "",
        "## Netflix / Video Streaming (Hard)",
        "Key challenges:",
        "- Video encoding and transcoding",
        "- Adaptive bitrate streaming",
        "- Global content delivery",
        "",
        "**Solution**",
        "- **Storage**: ",
        "  - Master videos in S3.",
        "  - Encoded versions (multiple bitrates) in S3.",
        "- **Encoding**: Video uploaded → Transcode to multiple formats (1080p, 720p, 480p, 360p) + codecs (H.264, VP9).",
        "- **Streaming**: Adaptive Bitrate Streaming (ABR). Client switches quality based on bandwidth.",
        "- **CDN**: Multi-CDN strategy. Push popular content to edge. Open Connect (Netflix's own CDN).",
        "- **Recommendation**: ML models (collaborative filtering). Precompute recommendations.",
        "",
        "## Uber / Ride-Sharing (Hard)",
        "Key challenges:",
        "- Real-time location tracking",
        "- Driver-rider matching",
        "- ETA calculation",
        "",
        "**Solution**",
        "- **Geospatial Index**: QuadTree or Geohash to index drivers by location.",
        "- **Matching Algorithm**: ",
        "  1. Find nearby drivers (within 2km radius).",
        "  2. Filter by car type, rating.",
        "  3. Assign closest available driver.",
        "- **Real-time Updates**: WebSocket for live location. Riders see driver moving.",
        "- **ETA**: Use Google Maps API or custom routing engine.",
        "- **Database**: ",
        "  - Trips in PostgreSQL (ACID for payments).",
        "  - Real-time locations in Redis (TTL 1 minute).",
        "- **Surge Pricing**: Dynamic pricing based on supply/demand. Kafka for event streaming.",
        "",
        "## BookMyShow / Ticketing (Medium)",
        "Key challenges:",
        "- Handling concurrent bookings",
        "- Seat locking mechanism",
        "- Payment integration",
        "",
        "**Solution**",
        "- **Seat Locking**: ",
        "  - User selects seats → Lock for 5 minutes.",
        "  - Distributed lock (Redis with SETNX).",
        "  - Timeout releases lock automatically.",
        "- **Concurrency**: ",
        "  - Optimistic locking (version number in DB).",
        "  - If seat already booked, show error.",
        "- **Database**: SQL (PostgreSQL) for ACID transactions. Seat availability denormalized.",
        "- **Payment Flow**: ",
        "  1. Lock seats.",
        "  2. Process payment (3rd party - Stripe).",
        "  3. Confirm booking OR release lock.",
        "- **Scalability**: Partition by city/theater. Read replicas for browsing.",
        "",
        "## Airbnb / Rental Marketplace (Hard)",
        "Key challenges:",
        "- Geospatial search",
        "- Availability calendar",
        "- Booking conflicts",
        "",
        "**Solution**",
        "- **Search**: ",
        "  - ElasticSearch for full-text search (location, amenities, price).",
        "  - Geohash for nearby properties.",
        "- **Availability**: ",
        "  - Calendar stored as bit array (1 = available, 0 = booked).",
        "  - Check-in/Check-out validation (no overlaps).",
        "- **Booking**: ",
        "  - Pessimistic locking during reservation.",
        "  - ACID transaction (SQL) to prevent double-booking.",
        "- **Pricing**: Dynamic pricing algorithm (demand, season, events).",
        "- **Database**: ",
        "  - Properties in PostgreSQL.",
        "  - Search index in ElasticSearch.",
        "  - Images in S3 + CDN.",
        "",
        "## Airline Management System (Hard)",
        "Key challenges:",
        "- Seat inventory management",
        "- Overbooking strategy",
        "- Multi-leg flight booking",
        "",
        "**Solution**",
        "- **Seat Inventory**: ",
        "  - Real-time seat availability.",
        "  - Distributed lock for booking (similar to BookMyShow).",
        "- **Overbooking**: ",
        "  - Predictive model (10% no-show rate → sell 110 seats for 100-seat flight).",
        "  - Compensation algorithm for bumped passengers.",
        "- **Multi-leg Flights**: ",
        "  - Graph database or relational joins.",
        "  - DFS/BFS for route finding.",
        "- **Database**: ",
        "  - Flights, Bookings in PostgreSQL (ACID).",
        "  - Seat maps cached in Redis.",
        "- **Payment**: Two-phase commit for multi-leg bookings.",
        "- **Scalability**: Partition by airline/region.",
        "",
        "## Distributed Cache (Hard)",
        "Key challenges:",
        "- Consistent hashing",
        "- Cache invalidation",
        "- Replication and partitioning",
        "",
        "**Solution**",
        "- **Partitioning**: Consistent Hashing (Ring) to minimize data movement when nodes change.",
        "- **Failure Handling**: Gossip Protocol for node health. Replication for availability.",
        "- **Eviction**: LRU (Least Recently Used) or LFU (Least Frequently Used).",
        "",
        "## YouTube/Video Platform (Hard)",
        "Key challenges:",
        "- Video transcoding",
        "- CDN for delivery",
        "- Recommendation system",
        "",
        "**Solution**",
        "- **Storage**: Blob storage (S3) for raw and encoded files.",
        "- **Processing**: Async workers transcode video to streams (HLS/DASH) and different resolutions.",
        "- **Delivery**: CDN (CloudFront) to cache video chunks at edge locations.",
        "",
        "## Google Search (Very Hard)",
        "Key challenges:",
        "- Crawling and indexing",
        "- Ranking algorithms",
        "- Autocomplete system",
        "",
        "**Solution**",
        "- **Crawler**: URL Frontier manages queues of URLs to visit. ",
        "- **Indexer**: MapReduce jobs build **Inverted Index** (Word -> List of Doc IDs).",
        "- **Serving**: Shard index by Document ID. Scatter-gather architecture queries all shards and merges results."
      ],
      "keyPoints": [
        "Start with simpler designs",
        "Each system teaches different concepts",
        "Focus on key challenges, not every detail",
        "Practice explaining out loud"
      ]
    },
    {
      "id": "databases",
      "title": "Databases in System Design",
      "description": "Choosing and optimizing databases for scale",
      "content": [
        "Database selection and optimization are critical decisions in system design.",
        "",
        "## SQL vs NoSQL",
        "",
        "**SQL (Relational)**",
        "- ACID guarantees (Atomicity, Consistency, Isolation, Durability)",
        "- Structured schema with relationships",
        "- Strong consistency, JOIN operations",
        "- Use when: Banking, complex transactions, strict data integrity",
        "- Examples: PostgreSQL, MySQL",
        "",
        "**NoSQL**",
        "- Flexible schema, horizontal scaling",
        "- Eventually consistent (usually)",
        "- Types: Document, Key-Value, Wide-Column, Graph",
        "- Use when: High write throughput, flexible schema, rapid scaling",
        "- Examples: MongoDB, Cassandra, DynamoDB, Redis",
        "",
        "## Database Replication",
        "**Master-Slave**: Master handles writes, slaves handle reads. Async replication.",
        "**Master-Master**: Both handle writes. Complex conflict resolution.",
        "",
        "## Database Sharding",
        "Partition data across multiple databases based on shard key.",
        "- **Horizontal**: Split rows across shards",
        "- **Vertical**: Split columns (tables) across databases",
        "- Challenges: Cross-shard queries, rebalancing",
        "",
        "## Storage Types",
        "- **Block Storage**: Low-level, for databases/VMs (EBS)",
        "- **Object Storage**: Flat namespace, metadata, for unstructured data (S3)",
        "- **File Storage**: Hierarchical, shared access (EFS, NFS)"
      ],
      "keyPoints": [
        "Choose SQL for transactions, NoSQL for scale",
        "Replication increases read capacity and availability",
        "Sharding distributes load but adds complexity",
        "Match storage type to access pattern"
      ]
    },
    {
      "id": "normalization-denormalization",
      "title": "Normalization & Denormalization",
      "description": "Optimizing database schema design",
      "content": [
        "Database schema optimization balances data integrity with performance.",
        "",
        "## Normalization",
        "Organize data to reduce redundancy and dependency.",
        "",
        "**Normal Forms**:",
        "- **1NF**: Atomic values, no repeating groups",
        "- **2NF**: 1NF + no partial dependencies",
        "- **3NF**: 2NF + no transitive dependencies",
        "- **BCNF**: Stricter 3NF",
        "",
        "**Benefits**: Data integrity, less redundancy, easier updates",
        "**Drawbacks**: Complex queries with many JOINs, slower reads",
        "",
        "## Denormalization",
        "Intentionally add redundancy to optimize read performance.",
        "",
        "**Techniques**:",
        "- Store computed values (e.g., total price)",
        "- Duplicate data across tables to avoid JOINs",
        "- Materialized views",
        "",
        "**Trade-offs**: Faster reads, but slower writes and risk of data inconsistency.",
        "",
        "**When to use**: Read-heavy systems, reporting/analytics, caching layer"
      ],
      "keyPoints": [
        "Normalize for write-heavy OLTP systems",
        "Denormalize for read-heavy OLAP systems",
        "Balance data integrity vs performance",
        "Use caching for frequently accessed denormalized data"
      ]
    },
    {
      "id": "redis",
      "title": "Redis - In-Memory Data Store",
      "description": "High-performance caching and data structures",
      "content": [
        "Redis is an in-memory key-value store known for extreme speed and versatile data structures.",
        "",
        "## Key Features",
        "- **In-Memory**: O(1) operations, sub-millisecond latency",
        "- **Data Structures**: Strings, Lists, Sets, Sorted Sets, Hashes, Bitmaps, HyperLogLogs",
        "- **Persistence**: Optional RDB snapshots or AOF logging",
        "- **Pub/Sub**: Message broadcasting",
        "- **TTL**: Automatic key expiration",
        "",
        "## Common Use Cases",
        "",
        "**Caching**: Session storage, API responses, database query results",
        "**Rate Limiting**: Token bucket with INCR and EXPIRE",
        "**Leaderboards**: Sorted Sets with scores",
        "**Real-time Analytics**: HyperLogLog for cardinality estimation",
        "**Queues**: Lists with LPUSH/RPOP",
        "",
        "## Eviction Policies",
        "- **LRU**: Least Recently Used",
        "- **LFU**: Least Frequently Used",
        "- **TTL**: Expiring keys first",
        "- **Random**: Random key removal"
      ],
      "keyPoints": [
        "Use Redis for caching and session management",
        "Choose data structure based on access pattern",
        "Set TTL to prevent memory overflow",
        "Enable persistence for critical data"
      ]
    },
    {
      "id": "dns",
      "title": "Domain Name System (DNS)",
      "description": "Translating domain names to IP addresses",
      "content": [
        "DNS is the internet's phone book, converting human-readable domain names to IP addresses.",
        "",
        "## DNS Hierarchy",
        "",
        "1. **Root Servers**: Top-level (.) - 13 root server clusters",
        "2. **TLD Servers**: .com, .org, .net",
        "3. **Authoritative Name Servers**: Actual domain records",
        "4. **Recursive Resolvers**: ISP/Google DNS (8.8.8.8)",
        "",
        "## DNS Resolution Process",
        "",
        "1. User requests example.com",
        "2. Browser checks local cache",
        "3. If miss, query recursive resolver",
        "4. Resolver queries root → TLD → authoritative",
        "5. Authoritative returns IP address",
        "6. Resolver caches and returns to client",
        "",
        "## DNS Record Types",
        "- **A**: IPv4 address",
        "- **AAAA**: IPv6 address",
        "- **CNAME**: Canonical name (alias)",
        "- **MX**: Mail server",
        "- **NS**: Name server",
        "- **TXT**: Text (verification, SPF)",
        "",
        "## DNS Caching & TTL",
        "**TTL (Time To Live)**: How long to cache DNS record",
        "- Short TTL (60s): Fast updates, more DNS queries",
        "- Long TTL (24h): Fewer queries, slower updates",
        "",
        "**Caching Layers**: Browser → OS → Resolver → Authoritative"
      ],
      "keyPoints": [
        "DNS adds latency - cache aggressively",
        "Use CDN/GeoDNS for geographic load balancing",
        "Short TTL for dynamic IPs, long for static",
        "DNS can be a single point of failure - use multiple name servers"
      ]
    },
    {
      "id": "cdn-advanced",
      "title": "Content Delivery Network (CDN)",
      "description": "Distribute static content globally",
      "content": [
        "CDNs cache content at edge locations worldwide, reducing latency and offloading origin servers.",
        "",
        "## How CDN Works",
        "",
        "1. User requests asset (e.g., image.png)",
        "2. DNS routes to nearest edge server",
        "3. If edge has cached copy, serve immediately (cache hit)",
        "4. If not (cache miss), edge fetches from origin, caches, then serves",
        "",
        "## Key Concepts",
        "",
        "**Edge Locations**: Geographically distributed servers (100s globally)",
        "**Origin Server**: Source of truth for content",
        "**Cache Hit Ratio**: % of requests served from cache (aim for >90%)",
        "**Invalidation**: Purging stale content (costly - design for versioning instead)",
        "",
        "## CDN Strategies",
        "",
        "**Pull CDN**: Cache on first request (lazy loading)",
        "- Good for: Long-tail content, less predictable traffic",
        "",
        "**Push CDN**: Proactively upload content to edge",
        "- Good for: Popular content, controlled releases",
        "",
        "## Benefits",
        "- **Reduced Latency**: Serve from nearest location",
        "- **Reduced Bandwidth**: Offload 80%+ traffic from origin",
        "- **DDoS Protection**: Distribute attack surface",
        "- **High Availability**: Redundant edge servers"
      ],
      "keyPoints": [
        "Use CDN for all static assets (images, CSS, JS, videos)",
        "Set long cache headers (immutable + versioning)",
        "Monitor cache hit ratio",
        "Consider costs - egress bandwidth can be expensive"
      ]
    },
    {
      "id": "testing",
      "title": "Testing in System Design",
      "description": "Ensuring system correctness and reliability",
      "content": [
        "Testing validates that systems work correctly under various conditions.",
        "",
        "## Unit Testing",
        "Test individual components in isolation.",
        "",
        "**Characteristics**:",
        "- Fast (milliseconds)",
        "- No external dependencies (mock/stub)",
        "- High code coverage (70-80%+)",
        "",
        "**Best Practices**:",
        "- One assertion per test",
        "- Test edge cases and error paths",
        "- Follow AAA: Arrange, Act, Assert",
        "",
        "## Integration Testing",
        "Test interactions between components.",
        "",
        "**Examples**:",
        "- API endpoint testing",
        "- Database integration",
        "- Message queue consumers/producers",
        "",
        "**Challenges**: Slower, need test environment, harder to debug",
        "",
        "## End-to-End (E2E) Testing",
        "Test complete user workflows.",
        "- Use tools like Selenium, Cypress, Playwright",
        "- Slow and brittle, but high confidence",
        "- Keep E2E tests minimal (happy paths only)",
        "",
        "## Testing Pyramid",
        "```",
        "    /E2E\\",
        "   /Integration\\",
        "  /___Unit___\\",
        "```",
        "More unit tests, fewer E2E tests."
      ],
      "keyPoints": [
        "Follow testing pyramid - mostly unit tests",
        "Mock external dependencies in unit tests",
        "Run tests in CI/CD pipeline",
        "Aim for 80% code coverage, 100% critical path coverage"
      ]
    },
    {
      "id": "cicd",
      "title": "CI/CD Pipeline",
      "description": "Continuous Integration and Deployment",
      "content": [
        "CI/CD automates the software delivery process from code commit to production deployment.",
        "",
        "## Continuous Integration (CI)",
        "Automatically build and test code on every commit.",
        "",
        "**Steps**:",
        "1. Developer pushes code to Git",
        "2. CI server (Jenkins, GitHub Actions, CircleCI) detects change",
        "3. Run tests (unit, integration, linting)",
        "4. Build artifacts (Docker image, JAR, binary)",
        "5. Report results (pass/fail)",
        "",
        "**Benefits**: Catch bugs early, ensure code quality, faster feedback",
        "",
        "## Continuous Deployment (CD)",
        "Automatically deploy passing builds to production.",
        "",
        "**Deployment Strategies**:",
        "",
        "**Blue-Green**: Maintain two identical environments. Switch traffic instantly.",
        "- Pros: Zero downtime, instant rollback",
        "- Cons: 2x infrastructure cost",
        "",
        "**Canary**: Deploy to small % of users first, gradually increase.",
        "- Pros: Risk mitigation, real user testing",
        "- Cons: Complex routing, monitoring needed",
        "",
        "**Rolling**: Update servers one-by-one.",
        "- Pros: No extra infrastructure",
        "- Cons: Mixed versions during deployment",
        "",
        "## CI/CD Best Practices",
        "- Automate everything (tests, builds, deploys)",
        "- Keep builds fast (<10 minutes)",
        "- Deploy small, frequent changes",
        "- Monitor deployments and rollback quickly",
        "- Use feature flags for gradual rollouts"
      ],
      "keyPoints": [
        "Every code change triggers automated tests",
        "Deploy to staging before production",
        "Use canary or blue-green for zero-downtime deploys",
        "Automate rollbacks for failed deployments"
      ]
    },
    {
      "id": "consensus-algorithms",
      "title": "Consensus Algorithms",
      "description": "Agreement in distributed systems",
      "content": [
        "Consensus algorithms enable distributed systems to agree on a single value despite node failures.",
        "",
        "## Why Consensus?",
        "In distributed systems, nodes must agree on:",
        "- Which server is the leader",
        "- Order of operations (transactions)",
        "- Current state of the system",
        "",
        "## Raft Consensus",
        "Easier-to-understand alternative to Paxos.",
        "",
        "**Key Concepts**:",
        "- **Leader Election**: One leader handles all writes",
        "- **Log Replication**: Leader replicates log entries to followers",
        "- **Term**: Logical clock for leadership changes",
        "- **Quorum**: Majority (n/2 + 1) must agree",
        "",
        "**Process**:",
        "1. Leader receives client request",
        "2. Leader appends to its log",
        "3. Leader replicates entry to followers",
        "4. Once majority acknowledge, leader commits",
        "5. Leader notifies followers to commit",
        "",
        "## Paxos",
        "Classic consensus algorithm, more complex.",
        "- Proposers, Acceptors, Learners",
        "- Two-phase protocol (prepare, accept)",
        "- Used in Google Chubby, Apache ZooKeeper",
        "",
        "## Use Cases",
        "- Leader election (etcd, Consul)",
        "- Distributed databases (CockroachDB)",
        "- Configuration management (ZooKeeper)"
      ],
      "keyPoints": [
        "Consensus requires majority (quorum)",
        "Raft is easier to implement than Paxos",
        "Trade-off: Consistency for availability during partition",
        "Use existing tools (etcd, ZooKeeper) instead of implementing"
      ]
    },
    {
      "id": "distributed-tracing",
      "title": "Distributed Tracing",
      "description": "Debugging across microservices",
      "content": [
        "Distributed tracing tracks requests as they flow through multiple services in a microservices architecture.",
        "",
        "## The Problem",
        "In monoliths, debugging is straightforward - single call stack.",
        "In microservices:",
        "- Request touches 10+ services",
        "- Each service has its own logs",
        "- How to correlate logs across services?",
        "",
        "## How Tracing Works",
        "",
        "**Trace**: End-to-end request journey",
        "**Span**: Single operation (e.g., HTTP call, database query)",
        "**Trace ID**: Unique identifier for entire request",
        "**Span ID**: Unique identifier for each operation",
        "",
        "**Process**:",
        "1. API Gateway generates Trace ID",
        "2. Each service creates Span ID for its work",
        "3. Services pass Trace ID + Parent Span ID in headers",
        "4. All spans are sent to tracing backend",
        "5. Tracing UI visualizes the call graph",
        "",
        "## Popular Tools",
        "",
        "**Jaeger**: Open-source, CNCF project",
        "**Zipkin**: Twitter's open-source tracer",
        "**Datadog APM**: Commercial, all-in-one observability",
        "**AWS X-Ray**: Native AWS tracing",
        "",
        "## Benefits",
        "- Identify slow services (latency)",
        "- Find error sources quickly",
        "- Understand service dependencies",
        "- Optimize performance bottlenecks"
      ],
      "keyPoints": [
        "Essential for microservices debugging",
        "Use OpenTelemetry for vendor-neutral instrumentation",
        "Sample traces (e.g., 1%) in high-traffic systems",
        "Monitor key metrics: latency p50, p95, p99"
      ]
    },
    {
      "id": "performance-optimization",
      "title": "Performance Optimization",
      "description": "Techniques to improve system performance",
      "content": [
        "Performance optimization improves speed, scalability, and user experience.",
        "",
        "## Database Optimization",
        "",
        "**Indexing**: Create indexes on frequently queried columns",
        "- B-Tree indexes for range queries",
        "- Hash indexes for exact matches",
        "- Watch out: Indexes slow down writes",
        "",
        "**Query Optimization**:",
        "- Avoid SELECT * (fetch only needed fields)",
        "- Use LIMIT for pagination",
        "- Analyze query plans (EXPLAIN)",
        "- Denormalize for read-heavy workloads",
        "",
        "**Connection Pooling**: Reuse database connections instead of creating new ones",
        "",
        "## Caching Strategies",
        "- **Application Cache**: Redis/Memcached for API responses",
        "- **Database Cache**: Query result cache",
        "- **CDN**: Static assets at edge",
        "- **Browser Cache**: Cache-Control headers",
        "",
        "## Code-Level Optimizations",
        "",
        "**Lazy Loading**: Load data only when needed",
        "**Pagination**: Don't load all results at once",
        "**Async Processing**: Use message queues for non-critical tasks",
        "**Compression**: Gzip responses (70% smaller)",
        "",
        "## Frontend Optimization",
        "- **Code Splitting**: Load JS on-demand",
        "- **Image Optimization**: WebP format, lazy loading, responsive images",
        "- **Minification**: Remove whitespace from CSS/JS",
        "- **Critical CSS**: Inline above-the-fold styles",
        "",
        "## Monitoring & Profiling",
        "- **APM Tools**: Identify slow queries, N+1 problems",
        "- **Load Testing**: Find breaking points (k6, JMeter)",
        "- **Profiling**: CPU/Memory profiling in production"
      ],
      "keyPoints": [
        "Measure before optimizing (premature optimization is evil)",
        "Cache aggressively, invalidate carefully",
        "Optimize the critical path first (80/20 rule)",
        "Monitor p95/p99 latency, not just average"
      ]
    },
    {
      "id": "interview-tips",
      "title": "System Design Interview Tips",
      "description": "Master the system design interview process",
      "content": [
        "System design interviews are intentionally open-ended. Success requires both technical knowledge and communication skills.",
        "",
        "## Interview Format (45-60 minutes)",
        "",
        "**Phase 1: Requirements (5-10 min)**",
        "- Clarify functional requirements",
        "- Define non-functional requirements (scale, performance)",
        "- Agree on scope",
        "",
        "**Phase 2: High-Level Design (10-15 min)**",
        "- Draw box-and-arrow diagram",
        "- Identify major components (API Gateway, Load Balancer, Databases, Cache)",
        "- Explain data flow",
        "",
        "**Phase 3: Deep Dive (20-30 min)**",
        "- Discuss scalability bottlenecks",
        "- Database schema or API design",
        "- Trade-offs and alternatives",
        "",
        "**Phase 4: Wrap Up (5 min)**",
        "- Address remaining concerns",
        "- Discuss monitoring, deployment",
        "",
        "## Key Strategies",
        "",
        "**1. Ask Questions First**",
        "Don't jump to solutions. Clarify:",
        "- How many users? (100 or 100 million?)",
        "- Read-heavy or write-heavy?",
        "- Latency requirements? (<100ms for real-time)",
        "- Consistency vs Availability trade-off?",
        "",
        "**2. Start Simple, Then Scale**",
        "- Begin with single-server architecture",
        "- Identify bottlenecks",
        "- Add components (cache, CDN, read replicas)",
        "- Justify each addition",
        "",
        "**3. Use Numbers (Back-of-Envelope)**",
        "- QPS (Queries Per Second): 1M users × 10 requests/day ÷ 86400 sec ≈ 115 QPS",
        "- Storage: 1M users × 1KB profile × 5 years ≈ 5TB",
        "- Bandwidth: 115 QPS × 10KB response ≈ 1.15 MB/s",
        "",
        "**4. Draw Diagrams**",
        "- Visual > Text",
        "- Label components clearly",
        "- Show data flow with arrows",
        "",
        "**5. Discuss Trade-offs**",
        "- SQL vs NoSQL",
        "- Consistency vs Availability (CAP theorem)",
        "- Latency vs Cost",
        "",
        "**6. Think Out Loud**",
        "- Explain your reasoning",
        "- Admit unknowns",
        "- Propose multiple solutions",
        "",
        "## Common Pitfalls to Avoid",
        "",
        "❌ **Over-engineering**: Don't add Kafka if you only need a queue",
        "❌ **Under-engineering**: Don't use single server for 1B users",
        "❌ **Ignoring constraints**: If interviewer says \"low latency,\" use caching",
        "❌ **Silent thinking**: Speak your thought process",
        "❌ **Skipping requirements**: Clarify before designing"
      ],
      "keyPoints": [
        "Clarify requirements before designing",
        "Start simple, identify bottlenecks, then scale",
        "Use back-of-envelope calculations",
        "Draw diagrams and explain trade-offs",
        "Think out loud and discuss alternatives"
      ]
    },
    {
      "id": "crack-system-design",
      "title": "How to Crack System Design Interviews",
      "description": "Step-by-step framework for success",
      "content": [
        "Follow this proven framework to tackle any system design question confidently.",
        "",
        "",
        "",
        "```mermaid",
        "flowchart TD",
        "    Start[Start Interview]",
        "    ",
        "    Start --> Q1[1. Clarify Requirements<br/>Functional + Non-Functional]",
        "    Q1 --> Q2[2. Capacity Estimation<br/>Users • QPS • Storage]",
        "    Q2 --> Q3[3. Define APIs<br/>Endpoints • Request/Response]",
        "    Q3 --> Q4[4. Data Model<br/>Tables • Schema • Relationships]",
        "    Q4 --> Q5[5. High-Level Design<br/>Components • Data Flow]",
        "    Q5 --> Q6[6. Deep Dive<br/>Scale • Bottlenecks]",
        "    Q6 --> Q7[7. Trade-offs Discussion<br/>Consistency vs Availability]",
        "    ",
        "    Q7 --> End[Complete]",
        "    ",
        "    style Q1 fill:#10b981",
        "    style Q2 fill:#3b82f6",
        "    style Q3 fill:#f59e0b",
        "    style Q4 fill:#8b5cf6",
        "    style Q5 fill:#10b981",
        "    style Q6 fill:#3b82f6",
        "    style Q7 fill:#f59e0b",
        "```",
        "",
        "",
        "## The 7-Step Framework",
        "",
        "### Step 1: Understand the Problem & Gather Requirements (5 min)",
        "",
        "**Ask Clarifying Questions**:",
        "- What are the core features? (MVP vs nice-to-have)",
        "- Who are the users? (B2C, B2B, internal tool)",
        "- How many users? (100, 10K, 100M)",
        "- Expected growth rate?",
        "",
        "**Three Types of Requirements**:",
        "",
        "**1. Functional Requirements** (What the system does):",
        "- User can upload videos",
        "- User can watch videos",
        "- User can search videos",
        "",
        "**2. Non-Functional Requirements** (How well it does it):",
        "- Availability: 99.9% uptime",
        "- Latency: Video starts in <2 seconds",
        "- Scale: 1M daily active users, 10K uploads/day",
        "- Consistency vs Eventual Consistency",
        "",
        "**3. Extended Requirements** (Nice-to-have):",
        "- Analytics and reporting",
        "- Recommendation system",
        "- Live streaming support",
        "",
        "**Example**: Design YouTube",
        "- Q: Upload only or also streaming?",
        "- Q: How many video uploads per day?",
        "- Q: What video resolutions to support?",
        "- Q: Do we need live streaming?",
        "",
        "### Step 2: Estimation and Constraints (5 min)",
        "",
        "**Traffic Estimation**:",
        "- 1M DAU × 10 videos watched/day = 10M views/day",
        "- 10M views ÷ 86400 sec ≈ 115 views/second (average)",
        "- Peak traffic: 3-5x average = 350-575 QPS",
        "",
        "**Storage Estimation**:",
        "- 10K uploads/day × 100MB/video = 1TB/day",
        "- 1TB × 365 days ≈ 365TB/year",
        "- With replication (3x): ~1PB/year",
        "",
        "**Bandwidth Estimation**:",
        "- 115 views/sec × 5MB chunk = 575 MB/sec egress",
        "- 10K uploads/day ÷ 86400 × 100MB ≈ 115 MB/sec ingress",
        "",
        "**Key Questions**:",
        "- What is the read/write ratio? (100:1 for YouTube)",
        "- How many requests per second?",
        "- How much storage needed over 5 years?",
        "",
        "### Step 3: High-Level Design (15 min)",
        "",
        "**Identify Major Components**:",
        "- Load Balancer",
        "- API Gateway",
        "- Application Servers",
        "- Database (SQL vs NoSQL?)",
        "- Cache Layer",
        "- Message Queue",
        "- Storage (Blob storage for videos)",
        "",
        "**Draw Architecture Diagram**:",
        "```",
        "[Client] → [CDN] → [Load Balancer]",
        "                         ↓",
        "              [API Gateway]",
        "               /         \\",
        "      [Video Service]  [Metadata Service]",
        "           |                    |",
        "      [S3 Storage]    [PostgreSQL + Redis]",
        "           ↓",
        "    [Transcoding Queue]",
        "```",
        "",
        "**Explain Data Flow**:",
        "1. User uploads video → API Gateway → Video Service → S3",
        "2. Async job transcodes video to multiple formats",
        "3. Metadata stored in PostgreSQL",
        "4. Popular videos cached in CDN",
        "",
        "**Key Decisions**:",
        "- Monolithic vs Microservices?",
        "- SQL vs NoSQL?",
        "- Synchronous vs Asynchronous processing?",
        "",
        "### Step 4: Data Model Design (10 min)",
        "",
        "**Define Entities and Relationships**:",
        "",
        "```sql",
        "Users",
        "- user_id (PK)",
        "- username",
        "- email",
        "- created_at",
        "",
        "Videos",
        "- video_id (PK)",
        "- user_id (FK → Users)",
        "- title",
        "- description",
        "- url",
        "- views",
        "- duration",
        "- created_at",
        "",
        "Comments",
        "- comment_id (PK)",
        "- video_id (FK → Videos)",
        "- user_id (FK → Users)",
        "- text",
        "- created_at",
        "",
        "Likes",
        "- like_id (PK)",
        "- video_id (FK → Videos)",
        "- user_id (FK → Users)",
        "- created_at",
        "```",
        "",
        "**Key Questions**:",
        "- What are the different entities?",
        "- What are the relationships between entities?",
        "- How many tables do we need?",
        "- Is NoSQL better for this use case?",
        "",
        "### Step 5: API Design (5 min)",
        "",
        "**Define Clear Interfaces**:",
        "",
        "```typescript",
        "// Video APIs",
        "POST /api/v1/videos/upload",
        "GET /api/v1/videos/{videoId}",
        "DELETE /api/v1/videos/{videoId}",
        "GET /api/v1/videos/search?q={query}&page={page}",
        "",
        "// User APIs",
        "POST /api/v1/users/register",
        "GET /api/v1/users/{userId}",
        "PUT /api/v1/users/{userId}",
        "",
        "// Interaction APIs",
        "POST /api/v1/videos/{videoId}/like",
        "POST /api/v1/videos/{videoId}/comments",
        "GET /api/v1/videos/{videoId}/comments",
        "```",
        "",
        "**Keep it Simple**: Don't write full code, just define the interface.",
        "",
        "### Step 6: Deep Dive (15 min)",
        "",
        "**Pick 2-3 Components Based on Interviewer's Interest**:",
        "",
        "**Example 1: Scalability**",
        "- Database: Shard by video_id (hash-based partitioning)",
        "- Caching: Redis for video metadata, CDN for video content",
        "- Load Balancing: Consistent hashing for cache distribution",
        "",
        "**Example 2: Availability**",
        "- Database replication (Master-Slave)",
        "- Multi-region deployment",
        "- Circuit breaker pattern for service failures",
        "",
        "**Example 3: Performance**",
        "- CDN for video delivery (reduce latency)",
        "- Database indexing on video_id, user_id",
        "- Async processing for transcoding",
        "",
        "**Questions to Address**:",
        "- How should we partition our data?",
        "- What about load distribution?",
        "- Should we use cache? Where?",
        "- How will we handle a sudden spike in traffic?",
        "",
        "### Step 7: Identify Bottlenecks & Optimize (10 min)",
        "",
        "**Potential Bottlenecks**:",
        "1. **Single Point of Failure**: Add load balancer redundancy",
        "2. **Database Overload**: Add read replicas, implement sharding",
        "3. **Popular Video Spike**: Pre-warm cache, use CDN",
        "4. **Upload Surge**: Message queue for transcoding",
        "5. **Network Latency**: Multi-region CDN deployment",
        "",
        "**Optimization Strategies**:",
        "- Database indexing for faster queries",
        "- Caching at multiple layers",
        "- Asynchronous processing",
        "- Data compression",
        "- Rate limiting to prevent abuse",
        "",
        "## Communication Strategies",
        "",
        "### The 80-20 Rule",
        "**80% You Talking, 20% Interviewer**",
        "- Drive the conversation",
        "- Explain your thought process",
        "- Ask for feedback periodically",
        "- Don't go silent for too long",
        "",
        "### Do's ✅",
        "1. **Clarify First**: Ask questions before designing",
        "2. **Think Out Loud**: Verbalize your reasoning",
        "3. **Draw Diagrams**: Visual > Text",
        "4. **Justify Decisions**: Explain why you chose X over Y",
        "5. **Be Honest**: If you don't know something, say it",
        "6. **Stay Flexible**: Requirements may change during interview",
        "7. **Consider Trade-offs**: Discuss pros/cons of each approach",
        "8. **Check Time**: Manage your time across all steps",
        "",
        "### Don'ts ❌",
        "1. **Don't Use Buzzwords**: Only mention tech you understand",
        "2. **Don't Pretend Expertise**: Interviewer will ask follow-ups",
        "3. **Don't Go Too Deep Early**: Wait for interviewer's cue",
        "4. **Don't Force Architecture**: Don't fit everything into MVC if it doesn't fit",
        "5. **Don't Be Biased**: \"NoSQL is always better\" shows poor understanding",
        "6. **Don't Rush**: Take time to understand the problem",
        "7. **Don't Design in Silence**: Communicate throughout",
        "",
        "## Key Mindset",
        "",
        "**Treat Interviewer as Teammate**: This is a collaborative design session, not an interrogation.",
        "",
        "**Focus on Thought Process**: How you think matters more than the final design.",
        "",
        "**Demonstrate Ownership**: Lead the discussion, make decisions, explain trade-offs.",
        "",
        "## What Interviewers Look For",
        "",
        "✅ **Structured thinking**: Following a framework",
        "✅ **Trade-off analysis**: Discussing pros/cons",
        "✅ **Scalability mindset**: Thinking about 10x, 100x growth",
        "✅ **Practical experience**: Mentioning real technologies confidently",
        "✅ **Communication**: Clear, concise explanations",
        "✅ **Adaptability**: Adjusting design based on new requirements"
      ],
      "keyPoints": [
        "Follow 7-step framework: Requirements → Estimation → HLD → Data Model → API → Deep Dive → Bottlenecks",
        "Use 80-20 rule: Talk 80%, listen 20%",
        "Clarify functional, non-functional, and extended requirements",
        "Draw diagrams, design APIs, identify bottlenecks proactively",
        "Be honest, think out loud, justify all decisions"
      ]
    },
    {
      "id": "common-concepts",
      "title": "7 Common System Design Concepts",
      "description": "Master these essential patterns for interviews",
      "content": [
        "These concepts appear in almost every system design interview. Master them thoroughly.",
        "",
        "## 1. Load Balancing",
        "",
        "**What**: Distribute traffic across multiple servers.",
        "",
        "**Why**: ",
        "- Improve availability (if one server fails, others handle load)",
        "- Increase throughput (parallel processing)",
        "- Reduce latency (route to nearest server)",
        "",
        "**How**:",
        "- **Layer 4 (Transport)**: Route by IP/Port. Fast but less flexible.",
        "- **Layer 7 (Application)**: Route by URL, headers, cookies. Smarter routing.",
        "",
        "**Algorithms**:",
        "- **Round Robin**: Distribute evenly",
        "- **Least Connections**: Route to server with fewest active connections",
        "- **IP Hash**: Same client always hits same server (session affinity)",
        "",
        "**Examples**: Nginx, HAProxy, AWS ALB/NLB, TP-Link, Barracuda",
        "",
        "## 2. Caching",
        "",
        "**What**: Store frequently accessed data in faster storage (like keeping essentials in your fridge vs going to the store).",
        "",
        "**Why**: Reduce database load, improve response time",
        "",
        "**Where to Cache**:",
        "- **Browser**: Static assets (images, CSS, JS)",
        "- **CDN**: Videos, images at edge locations",
        "- **Application**: Redis/Memcached for API responses",
        "- **Database**: Query result cache",
        "",
        "**Eviction Policies**:",
        "- **LRU (Least Recently Used)**: Evict oldest access",
        "- **LFU (Least Frequently Used)**: Evict least popular",
        "- **TTL (Time To Live)**: Expire after time",
        "",
        "**Invalidation Strategies**:",
        "- **Write-through**: Update cache on write",
        "- **Write-around**: Invalidate cache on write",
        "- **Write-back**: Write to cache, async to DB",
        "",
        "**Popular Services**: Memcached, Redis, Cassandra, CDN (CloudFront, Akamai)",
        "",
        "## 3. Proxies",
        "",
        "**What**: Intermediary software/hardware between client and server.",
        "",
        "**Types**:",
        "",
        "**Forward Proxy** (Client-side):",
        "- Acts on behalf of the client",
        "- Hides client's identity from server",
        "- Used for: Filtering, anonymity, caching",
        "- Example: Corporate proxy, VPN",
        "",
        "**Reverse Proxy** (Server-side):",
        "- Acts on behalf of the server",
        "- Client doesn't know it's talking to a proxy",
        "- Used for: Load balancing, caching, security",
        "- Example: Nginx, HAProxy",
        "",
        "**Use Cases**:",
        "- **Filter requests**: Block malicious traffic",
        "- **Log requests**: Monitor traffic patterns",
        "- **Transform requests**: Add/remove headers, encrypt/decrypt",
        "- **Load balance**: Distribute traffic to backend servers",
        "- **Cache content**: Store responses for faster delivery",
        "",
        "**Key Difference**:",
        "- Forward Proxy: Server doesn't know client's IP",
        "- Reverse Proxy: Client doesn't know server's IP",
        "",
        "## 4. CAP Theorem",
        "",
        "**What**: You can only guarantee 2 out of 3 properties in a distributed system.",
        "",
        "**The 3 Properties**:",
        "",
        "**Consistency (C)**: All nodes see the same data at the same time",
        "- Every read gets the most recent write",
        "- Example: Bank transactions (must be accurate)",
        "",
        "**Availability (A)**: Every request gets a response (success/failure)",
        "- System responds even if some nodes are down",
        "- Example: Social media feeds (can tolerate slight delays)",
        "",
        "**Partition Tolerance (P)**: System continues despite network failures",
        "- MUST be supported in distributed systems",
        "- Network failures will happen",
        "",
        "**Trade-offs**:",
        "",
        "**CA (Consistency + Availability)**:",
        "- Not possible in distributed systems",
        "- Only works for single-node systems",
        "- Example: Traditional RDBMS on single server",
        "",
        "**CP (Consistency + Partition Tolerance)**:",
        "- Sacrifices availability during network partitions",
        "- Returns error if can't guarantee consistency",
        "- Example: Banking systems, HBase, MongoDB (strong consistency mode)",
        "",
        "**AP (Availability + Partition Tolerance)**:",
        "- Sacrifices consistency for availability",
        "- Always responds, but data may be stale",
        "- Example: DNS, Cassandra, DynamoDB",
        "",
        "**Real-World Examples**:",
        "- **Stock Trading**: CP (consistency critical)",
        "- **Social Media**: AP (availability more important)",
        "- **E-Commerce Cart**: AP (eventual consistency acceptable)",
        "",
        "## 5. Database Scaling",
        "",
        "**Vertical Scaling**: Bigger machine (more CPU/RAM)",
        "- **Pros**: Simple, no code changes",
        "- **Cons**: Hardware limits, expensive, single point of failure",
        "",
        "**Horizontal Scaling**: More machines",
        "",
        "**Replication**:",
        "- **Master-Slave**: Master for writes, slaves for reads",
        "  - Synchronous: Immediate consistency, slower writes",
        "  - Asynchronous: Faster writes, possible data loss",
        "- **Master-Master**: Both handle writes (complex conflict resolution)",
        "",
        "**Sharding (Partitioning)**:",
        "- **Horizontal**: Split rows across shards (by User ID, Geography)",
        "  - User 1-1M → Shard 1, User 1M-2M → Shard 2",
        "- **Vertical**: Split columns/tables across databases",
        "  - User table → DB1, Orders table → DB2",
        "",
        "**Database Indexing**:",
        "- Creates sorted data structure for fast lookups",
        "- Trade-off: Faster reads, slower writes",
        "- Example: Index on 'age' column for age-based queries",
        "",
        "**Challenges**: Cross-shard queries, rebalancing, joins",
        "",
        "## 6. Asynchronous Processing",
        "",
        "**What**: Decouple request from processing using message queues.",
        "",
        "**Why**: ",
        "- Handle spikes (queue absorbs burst)",
        "- Improve UX (respond immediately, process later)",
        "- Retry on failure",
        "",
        "**Pattern**:",
        "```",
        "Client → API → Queue → Workers → Database",
        "            ↓",
        "         (Immediate response)",
        "```",
        "",
        "**Examples**:",
        "- **Email sending**: Queue email, send async",
        "- **Image processing**: Upload image, resize async",
        "- **Video transcoding**: Upload video, transcode async",
        "",
        "**Technologies**: RabbitMQ, Kafka, SQS, Redis Pub/Sub",
        "",
        "## 7. Microservices vs Monolith",
        "",
        "**Monolith**: Single codebase, deployed as one unit",
        "- **Pros**: Simple to develop, easy debugging, ACID transactions",
        "- **Cons**: Hard to scale, tight coupling, deploy entire app for small change",
        "",
        "**Microservices**: Multiple small services, each with own database",
        "- **Pros**: Independent scaling, technology flexibility, fault isolation",
        "- **Cons**: Complex deployment, distributed transactions, testing harder",
        "",
        "**When to Use**:",
        "- **Monolith**: Startups, small teams, simple domains",
        "- **Microservices**: Large teams, complex domains, need independent scaling",
        "",
        "**Key Patterns**:",
        "- **API Gateway**: Single entry point",
        "- **Service Discovery**: Find service instances (Consul, Eureka)",
        "- **Circuit Breaker**: Fail fast on dependency failure",
        "",
        "## Interview Application",
        "",
        "**Example**: Design Instagram",
        "- **Load Balancing**: Distribute traffic to API servers",
        "- **Caching**: Redis for user feeds, CDN for images",
        "- **Proxies**: Reverse proxy for security and load balancing",
        "- **CAP**: AP system (availability over consistency for feeds)",
        "- **Database Scaling**: Shard by UserID, replicate for reads",
        "- **Async Processing**: Image resize, feed generation",
        "- **Microservices**: Photo Service, Feed Service, User Service"
      ],
      "keyPoints": [
        "Load Balancing: Distribute traffic, improve availability",
        "Caching: Multiple layers (Browser, CDN, App, DB)",
        "Proxies: Forward (client-side) vs Reverse (server-side)",
        "CAP Theorem: Choose 2 of 3 (Consistency, Availability, Partition Tolerance)",
        "Database Scaling: Replication + Sharding + Indexing",
        "Async Processing: Decouple with queues for spikes",
        "Microservices: Independent scaling, but added complexity"
      ]
    }
  ],
  "quizzes": [
    {
      "id": "system-design-fundamentals",
      "title": "System Design Fundamentals Quiz",
      "description": "Test your understanding of distributed systems concepts",
      "passingScore": 70,
      "questions": [
        {
          "id": "q1",
          "question": "According to CAP theorem, in the presence of a network partition, a distributed system must choose between:",
          "options": [
            "Consistency and Availability",
            "Speed and Security",
            "Cost and Performance",
            "None of the above"
          ],
          "correctIndex": 0,
          "explanation": "CAP theorem states that during a network partition (P), you must choose between Consistency (C) and Availability (A). You cannot have all three simultaneously.",
          "timeLimit": 25
        },
        {
          "id": "q2",
          "question": "Which caching strategy writes data to cache and database simultaneously?",
          "options": [
            "Write-around",
            "Write-through",
            "Write-behind",
            "Lazy-loading"
          ],
          "correctIndex": 1,
          "explanation": "Write-through writes to both cache and database at the same time, ensuring consistency but with higher latency. Write-behind is async, write-around skips cache.",
          "timeLimit": 25
        },
        {
          "id": "q3",
          "question": "What is the main purpose of consistent hashing in distributed systems?",
          "options": [
            "Encrypting data in transit",
            "Minimizing redistribution when nodes are added/removed",
            "Ensuring strong consistency",
            "Reducing query latency"
          ],
          "correctIndex": 1,
          "explanation": "Consistent hashing minimizes the number of keys that need to be remapped when nodes are added or removed from the system, typically only affecting K/N keys.",
          "timeLimit": 25
        },
        {
          "id": "q4",
          "question": "For a social media feed, 'fan-out on write' means:",
          "options": [
            "Computing feeds when users request them",
            "Pre-computing and distributing posts to followers' feeds",
            "Caching all posts in memory",
            "Sending push notifications for every post"
          ],
          "correctIndex": 1,
          "explanation": "Fan-out on write pre-computes feeds when a post is created, distributing it to all followers' feed caches. Good for fast reads but expensive for celebrities with millions of followers.",
          "timeLimit": 30
        },
        {
          "id": "q5",
          "question": "Which database type would be best for storing social connections (friends, followers)?",
          "options": [
            "Relational (SQL)",
            "Document (MongoDB)",
            "Key-Value (Redis)",
            "Graph (Neo4j)"
          ],
          "correctIndex": 3,
          "explanation": "Graph databases like Neo4j are optimized for traversing relationships, making them ideal for social connections, recommendations, and 'friends of friends' queries.",
          "timeLimit": 25
        },
        {
          "id": "q6",
          "question": "Which of the following describes 'Horizontal Scaling'?",
          "options": [
            "Adding more power (CPU, RAM) to an existing server",
            "Adding more servers to the pool of resources",
            "Optimizing the database queries",
            "Compressing data to save space"
          ],
          "correctIndex": 1,
          "explanation": "Horizontal scaling (scaling out) involves adding more machines to your resource pool, whereas vertical scaling (scaling up) involves adding more power to an existing machine.",
          "timeLimit": 20
        },
        {
          "id": "q7",
          "question": "Which load balancing algorithm directs traffic to the server with the fewest active connections?",
          "options": [
            "Round Robin",
            "IP Hash",
            "Least Connections",
            "Random"
          ],
          "correctIndex": 2,
          "explanation": "The Least Connections algorithm directs traffic to the server with the fewest active connections, which is useful when sessions have varying lengths.",
          "timeLimit": 20
        },
        {
          "id": "q8",
          "question": "What is Database Sharding?",
          "options": [
            "Replicating the database for backup",
            "Caching frequently accessed data",
            "Partitioning data across multiple machines based on a key",
            "Encrypting the database"
          ],
          "correctIndex": 2,
          "explanation": "Sharding is a method of splitting and storing a single logical dataset in multiple databases (shards) to spread the load.",
          "timeLimit": 25
        },
        {
          "id": "q9",
          "question": "What is the primary benefit of using a CDN (Content Delivery Network)?",
          "options": [
            "Processing complex logic on the edge",
            "Reducing latency for static assets by serving them from locations closer to the user",
            "Storing user session data",
            "Encrypting database connections"
          ],
          "correctIndex": 1,
          "explanation": "CDNs cache static content (images, CSS, JS) in geographically distributed servers, allowing users to download them from a server that is physically closer, reducing latency.",
          "timeLimit": 20
        },
        {
          "id": "q10",
          "question": "How do Message Queues (like Kafka or RabbitMQ) help in system design?",
          "options": [
            "They act as the primary database",
            "They allow direct synchronous communication between services",
            "They decouple services allowing for asynchronous processing and load smoothing",
            "They replace load balancers"
          ],
          "correctIndex": 2,
          "explanation": "Message queues decouple producers from consumers, allowing services to scale independently and handle spikes in load asynchronously.",
          "timeLimit": 25
        }
      ]
    }
  ]
}