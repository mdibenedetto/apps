{
  "id": "design-patterns",
  "title": "Design Patterns",
  "description": "Reusable solutions to common software design problems",
  "icon": "Boxes",
  "color": "design-patterns",
  "introduction": "Design Patterns are proven solutions to recurring design problems in software development. Created by the Gang of Four (GoF), these 23 patterns are divided into three categories: Creational, Structural, and Behavioral. This section covers the 15 most important patterns for technical interviews.",
  "topics": [
    {
      "id": "singleton",
      "title": "Singleton Pattern",
      "description": "Ensure a class has only one instance",
      "content": [
        "Singleton restricts instantiation of a class to a single object.",
        "",
        "## Use Cases",
        "- Database connections",
        "- Configuration managers",
        "- Logging services",
        "- Thread pools",
        "",
        "## Implementation",
        "```typescript",
        "class Singleton {",
        "  private static instance: Singleton;",
        "  private constructor() {} // Private constructor",
        "  ",
        "  static getInstance(): Singleton {",
        "    if (!Singleton.instance) {",
        "      Singleton.instance = new Singleton();",
        "    }",
        "    return Singleton.instance;",
        "  }",
        "}",
        "",
        "const s1 = Singleton.getInstance();",
        "const s2 = Singleton.getInstance();",
        "console.log(s1 === s2); // true",
        "```",
        "",
        "## Thread-Safety (Java)",
        "```java",
        "public class Singleton {",
        "    private static volatile Singleton instance;",
        "    ",
        "    public static Singleton getInstance() {",
        "        if (instance == null) {  // First check (no locking)",
        "            synchronized (Singleton.class) {",
        "                if (instance == null) {  // Double-check",
        "                    instance = new Singleton();",
        "                }",
        "            }",
        "        }",
        "        return instance;",
        "    }",
        "}",
        "```",
        "",
        "## Pros & Cons",
        "✅ Controlled access to single instance",
        "✅ Lazy initialization",
        "❌ Hard to test (global state)",
        "❌ Violates Single Responsibility Principle"
      ],
      "keyPoints": [
        "Private constructor prevents direct instantiation",
        "Static method provides global access point",
        "Use for stateless services (logger, config)",
        "Consider dependency injection instead for testability"
      ]
    },
    {
      "id": "factory",
      "title": "Factory Method Pattern",
      "description": "Create objects without specifying exact class",
      "content": [
        "Factory Method defines an interface for creating objects but lets subclasses decide which class to instantiate.",
        "",
        "## Problem",
        "You want to create objects but don't want to hardcode the exact class.",
        "",
        "## Solution",
        "```typescript",
        "interface Transport {",
        "  deliver(): void;",
        "}",
        "",
        "class Truck implements Transport {",
        "  deliver() { console.log('Deliver by land'); }",
        "}",
        "",
        "class Ship implements Transport {",
        "  deliver() { console.log('Deliver by sea'); }",
        "}",
        "",
        "abstract class Logistics {",
        "  abstract createTransport(): Transport;",
        "  ",
        "  planDelivery() {",
        "    const transport = this.createTransport();",
        "    transport.deliver();",
        "  }",
        "}",
        "",
        "class RoadLogistics extends Logistics {",
        "  createTransport(): Transport {",
        "    return new Truck();",
        "  }",
        "}",
        "",
        "class SeaLogistics extends Logistics {",
        "  createTransport(): Transport {",
        "    return new Ship();",
        "  }",
        "}",
        "",
        "// Usage",
        "const logistics = new RoadLogistics();",
        "logistics.planDelivery(); // Deliver by land",
        "```",
        "",
        "## Benefits",
        "- Decouples client code from concrete classes",
        "- Follows Open/Closed Principle",
        "- Easy to add new types"
      ],
      "keyPoints": [
        "Delegates object creation to subclasses",
        "Client works with interface, not concrete classes",
        "Use when you don't know exact types beforehand",
        "Common in frameworks and libraries"
      ]
    },
    {
      "id": "builder",
      "title": "Builder Pattern",
      "description": "Construct complex objects step by step",
      "content": [
        "Builder separates the construction of a complex object from its representation.",
        "",
        "## Problem",
        "Constructor with many parameters becomes unreadable.",
        "",
        "❌ **Bad**:",
        "```typescript",
        "new User('John', 'Doe', 30, 'john@example.com', '123 St', 'City', 'Country');",
        "// What do these values mean?",
        "```",
        "",
        "## Solution",
        "```typescript",
        "class User {",
        "  constructor(",
        "    public firstName: string,",
        "    public lastName: string,",
        "    public age?: number,",
        "    public email?: string,",
        "    public address?: string",
        "  ) {}",
        "}",
        "",
        "class UserBuilder {",
        "  private firstName!: string;",
        "  private lastName!: string;",
        "  private age?: number;",
        "  private email?: string;",
        "  private address?: string;",
        "  ",
        "  setFirstName(name: string) {",
        "    this.firstName = name;",
        "    return this;",
        "  }",
        "  ",
        "  setLastName(name: string) {",
        "    this.lastName = name;",
        "    return this;",
        "  }",
        "  ",
        "  setAge(age: number) {",
        "    this.age = age;",
        "    return this;",
        "  }",
        "  ",
        "  setEmail(email: string) {",
        "    this.email = email;",
        "    return this;",
        "  }",
        "  ",
        "  build(): User {",
        "    return new User(",
        "      this.firstName,",
        "      this.lastName,",
        "      this.age,",
        "      this.email,",
        "      this.address",
        "    );",
        "  }",
        "}",
        "",
        "// Usage",
        "const user = new UserBuilder()",
        "  .setFirstName('John')",
        "  .setLastName('Doe')",
        "  .setAge(30)",
        "  .setEmail('john@example.com')",
        "  .build();",
        "```",
        "",
        "## Use Cases",
        "- Objects with many optional parameters",
        "- Immutable objects",
        "- Complex configuration objects"
      ],
      "keyPoints": [
        "Fluent interface with method chaining",
        "Readable object construction",
        "Good for objects with many optional fields",
        "Ensures objects are fully constructed before use"
      ]
    },
    {
      "id": "adapter",
      "title": "Adapter Pattern",
      "description": "Make incompatible interfaces work together",
      "content": [
        "Adapter allows objects with incompatible interfaces to collaborate.",
        "",
        "## Problem",
        "You have an existing interface that doesn't match what the client expects.",
        "",
        "## Solution",
        "```typescript",
        "// Old system: XML data",
        "class XMLData {",
        "  getXMLData(): string {",
        "    return '<user><name>John</name></user>';",
        "  }",
        "}",
        "",
        "// New system expects JSON",
        "interface JSONData {",
        "  getJSONData(): object;",
        "}",
        "",
        "// Adapter",
        "class XMLToJSONAdapter implements JSONData {",
        "  constructor(private xmlData: XMLData) {}",
        "  ",
        "  getJSONData(): object {",
        "    const xml = this.xmlData.getXMLData();",
        "    // Convert XML to JSON (simplified)",
        "    return { user: { name: 'John' } };",
        "  }",
        "}",
        "",
        "// Client code",
        "function processData(data: JSONData) {",
        "  console.log(data.getJSONData());",
        "}",
        "",
        "const xmlData = new XMLData();",
        "const adapter = new XMLToJSONAdapter(xmlData);",
        "processData(adapter); // Works!",
        "```",
        "",
        "## Real-World Examples",
        "- Third-party library integration",
        "- Legacy code integration",
        "- API version compatibility"
      ],
      "keyPoints": [
        "Wraps an existing class with a new interface",
        "Translates one interface to another",
        "Use when you can't modify the existing class",
        "Common in integrating third-party libraries"
      ]
    },
    {
      "id": "decorator",
      "title": "Decorator Pattern",
      "description": "Add behavior to objects dynamically",
      "content": [
        "Decorator attaches new behaviors to objects by placing them inside wrapper objects.",
        "",
        "## Problem",
        "You want to add functionality without modifying existing code or using inheritance.",
        "",
        "## Solution",
        "```typescript",
        "interface Coffee {",
        "  cost(): number;",
        "  description(): string;",
        "}",
        "",
        "class SimpleCoffee implements Coffee {",
        "  cost() { return 5; }",
        "  description() { return 'Simple coffee'; }",
        "}",
        "",
        "// Decorator",
        "abstract class CoffeeDecorator implements Coffee {",
        "  constructor(protected coffee: Coffee) {}",
        "  abstract cost(): number;",
        "  abstract description(): string;",
        "}",
        "",
        "class MilkDecorator extends CoffeeDecorator {",
        "  cost() { return this.coffee.cost() + 2; }",
        "  description() { return this.coffee.description() + ', milk'; }",
        "}",
        "",
        "class SugarDecorator extends CoffeeDecorator {",
        "  cost() {return this.coffee.cost() + 1; }",
        "  description() { return this.coffee.description() + ', sugar'; }",
        "}",
        "",
        "// Usage",
        "let coffee: Coffee = new SimpleCoffee();",
        "coffee = new MilkDecorator(coffee);",
        "coffee = new SugarDecorator(coffee);",
        "",
        "console.log(coffee.description()); // 'Simple coffee, milk, sugar'",
        "console.log(coffee.cost()); // 8",
        "```",
        "",
        "## Benefits",
        "- Add responsibilities dynamically",
        "- More flexible than inheritance",
        "- Compose behaviors",
        "",
        "## Use Cases",
        "- Adding features to objects at runtime",
        "- Java I/O streams (BufferedReader wraps FileReader)",
        "- Middleware in Express.js"
      ],
      "keyPoints": [
        "Wraps object to add new behavior",
        "Composition over inheritance",
        "Stack decorators for multiple behaviors",
        "Follows Open/Closed Principle"
      ]
    },
    {
      "id": "observer",
      "title": "Observer Pattern",
      "description": "Notify multiple objects about state changes",
      "content": [
        "Observer defines a subscription mechanism to notify multiple objects about events.",
        "",
        "## Problem",
        "Multiple objects need to be notified when another object's state changes.",
        "",
        "## Solution",
        "```typescript",
        "interface Observer {",
        "  update(data: any): void;",
        "}",
        "",
        "class Subject {",
        "  private observers: Observer[] = [];",
        "  ",
        "  attach(observer: Observer) {",
        "    this.observers.push(observer);",
        "  }",
        "  ",
        "  detach(observer: Observer) {",
        "    const index = this.observers.indexOf(observer);",
        "    this.observers.splice(index, 1);",
        "  }",
        "  ",
        "  notify(data: any) {",
        "    for (const observer of this.observers) {",
        "      observer.update(data);",
        "    }",
        "  }",
        "}",
        "",
        "class NewsAgency extends Subject {",
        "  private news: string = '';",
        "  ",
        "  setNews(news: string) {",
        "    this.news = news;",
        "    this.notify(news);",
        "  }",
        "}",
        "",
        "class NewsChannel implements Observer {",
        "  constructor(private name: string) {}",
        "  ",
        "  update(news: string) {",
        "    console.log(`${this.name} received: ${news}`);",
        "  }",
        "}",
        "",
        "// Usage",
        "const agency = new NewsAgency();",
        "const cnn = new NewsChannel('CNN');",
        "const bbc = new NewsChannel('BBC');",
        "",
        "agency.attach(cnn);",
        "agency.attach(bbc);",
        "",
        "agency.setNews('Breaking news!'); // Both channels notified",
        "```",
        "",
        "## Use Cases",
        "- Event handling systems",
        "- MVC architecture (Model notifies View)",
        "- Pub/Sub messaging",
        "- React/Vue reactive systems"
      ],
      "keyPoints": [
        "One-to-many dependency",
        "Subject maintains list of observers",
        "Push or pull model for data",
        "Decouple sender from receivers"
      ]
    },
    {
      "id": "strategy",
      "title": "Strategy Pattern",
      "description": "Define a family of algorithms, make them interchangeable",
      "content": [
        "Strategy defines a family of algorithms, encapsulates each one, and makes them interchangeable.",
        "",
        "## Problem",
        "You have multiple ways to perform an operation and want to switch between them dynamically.",
        "",
        "## Solution",
        "```typescript",
        "interface PaymentStrategy {",
        "  pay(amount: number): void;",
        "}",
        "",
        "class CreditCardPayment implements PaymentStrategy {",
        "  pay(amount: number) {",
        "    console.log(`Paid ${amount} using Credit Card`);",
        "  }",
        "}",
        "",
        "class PayPalPayment implements PaymentStrategy {",
        "  pay(amount: number) {",
        "    console.log(`Paid ${amount} using PayPal`);",
        "  }",
        "}",
        "",
        "class CryptoPayment implements PaymentStrategy {",
        "  pay(amount: number) {",
        "    console.log(`Paid ${amount} using Cryptocurrency`);",
        "  }",
        "}",
        "",
        "class ShoppingCart {",
        "  private paymentStrategy!: PaymentStrategy;",
        "  ",
        "  setPaymentStrategy(strategy: PaymentStrategy) {",
        "    this.paymentStrategy = strategy;",
        "  }",
        "  ",
        "  checkout(amount: number) {",
        "    this.paymentStrategy.pay(amount);",
        "  }",
        "}",
        "",
        "// Usage",
        "const cart = new ShoppingCart();",
        "",
        "cart.setPaymentStrategy(new CreditCardPayment());",
        "cart.checkout(100); // Credit Card",
        "",
        "cart.setPaymentStrategy(new PayPalPayment());",
        "cart.checkout(200); // PayPal",
        "```",
        "",
        "## Benefits",
        "- Avoid complex conditionals (if/else, switch)",
        "- Easy to add new strategies",
        "- Runtime algorithm selection",
        "",
        "## Use Cases",
        "- Different sorting algorithms",
        "- Compression algorithms",
        "- Route calculation (car, bike, walk)"
      ],
      "keyPoints": [
        "Encapsulate algorithms in separate classes",
        "Client can switch strategies at runtime",
        "Eliminates conditionals",
        "Follows Open/Closed Principle"
      ]
    },
    {
      "id": "abstract-factory",
      "title": "Abstract Factory Pattern",
      "description": "Create families of related objects",
      "content": [
        "Abstract Factory provides an interface for creating families of related objects without specifying their concrete classes.",
        "",
        "## Problem",
        "You need to create sets of related objects that must work together.",
        "",
        "## Solution",
        "```typescript",
        "// Abstract products",
        "interface Button {",
        "  render(): void;",
        "}",
        "",
        "interface Checkbox {",
        "  render(): void;",
        "}",
        "",
        "// Concrete products - Windows",
        "class WindowsButton implements Button {",
        "  render() { console.log('Rendering Windows button'); }",
        "}",
        "",
        "class WindowsCheckbox implements Checkbox {",
        "  render() { console.log('Rendering Windows checkbox'); }",
        "}",
        "",
        "// Concrete products - Mac",
        "class MacButton implements Button {",
        "  render() { console.log('Rendering Mac button'); }",
        "}",
        "",
        "class MacCheckbox implements Checkbox {",
        "  render() { console.log('Rendering Mac checkbox'); }",
        "}",
        "",
        "// Abstract factory",
        "interface GUIFactory {",
        "  createButton(): Button;",
        "  createCheckbox(): Checkbox;",
        "}",
        "",
        "// Concrete factories",
        "class WindowsFactory implements GUIFactory {",
        "  createButton() { return new WindowsButton(); }",
        "  createCheckbox() { return new WindowsCheckbox(); }",
        "}",
        "",
        "class MacFactory implements GUIFactory {",
        "  createButton() { return new MacButton(); }",
        "  createCheckbox() { return new MacCheckbox(); }",
        "}",
        "",
        "// Client",
        "class Application {",
        "  constructor(private factory: GUIFactory) {}",
        "  ",
        "  createUI() {",
        "    const button = this.factory.createButton();",
        "    const checkbox = this.factory.createCheckbox();",
        "    button.render();",
        "    checkbox.render();",
        "  }",
        "}",
        "",
        "// Usage",
        "const isWindows = true;",
        "const factory = isWindows ? new WindowsFactory() : new MacFactory();",
        "const app = new Application(factory);",
        "app.createUI();",
        "```",
        "",
        "## vs Factory Method",
        "- **Factory Method**: Creates one type of product",
        "- **Abstract Factory**: Creates families of related products"
      ],
      "keyPoints": [
        "Creates families of related objects",
        "Ensures products are compatible",
        "Isolates concrete classes from client",
        "Use when system needs multiple product families"
      ]
    },
    {
      "id": "prototype",
      "title": "Prototype Pattern",
      "description": "Clone objects instead of creating new ones",
      "content": [
        "Prototype creates new objects by copying existing ones (prototypes).",
        "",
        "## Problem",
        "Object creation is expensive (database calls, complex initialization).",
        "",
        "## Solution",
        "```typescript",
        "interface Prototype {",
        "  clone(): Prototype;",
        "}",
        "",
        "class Circle implements Prototype {",
        "  constructor(",
        "    public x: number,",
        "    public y: number,",
        "    public radius: number,",
        "    public color: string",
        "  ) {}",
        "  ",
        "  clone(): Circle {",
        "    return new Circle(this.x, this.y, this.radius, this.color);",
        "  }",
        "}",
        "",
        "class Rectangle implements Prototype {",
        "  constructor(",
        "    public x: number,",
        "    public y: number,",
        "    public width: number,",
        "    public height: number",
        "  ) {}",
        "  ",
        "  clone(): Rectangle {",
        "    return new Rectangle(this.x, this.y, this.width, this.height);",
        "  }",
        "}",
        "",
        "// Usage",
        "const circle1 = new Circle(10, 20, 5, 'red');",
        "const circle2 = circle1.clone();",
        "circle2.color = 'blue';",
        "",
        "console.log(circle1.color); // 'red'",
        "console.log(circle2.color); // 'blue'",
        "```",
        "",
        "## Deep vs Shallow Copy",
        "- **Shallow**: Copies primitives, references to objects",
        "- **Deep**: Copies everything recursively",
        "",
        "## Use Cases",
        "- Cloning complex objects",
        "- Undo/Redo functionality",
        "- Avoiding repeated expensive initialization"
      ],
      "keyPoints": [
        "Clone existing objects instead of creating new",
        "Useful when creation is expensive",
        "Be aware of deep vs shallow copying",
        "JavaScript has built-in prototype chain"
      ]
    },
    {
      "id": "composite",
      "title": "Composite Pattern",
      "description": "Treat individual objects and compositions uniformly",
      "content": [
        "Composite lets you compose objects into tree structures and work with them as if they were individual objects.",
        "",
        "## Problem",
        "You have tree structures (files/folders, UI components) and want to treat leaf and composite nodes uniformly.",
        "",
        "## Solution",
        "```typescript",
        "interface Graphic {",
        "  draw(): void;",
        "}",
        "",
        "// Leaf",
        "class Circle implements Graphic {",
        "  draw() {",
        "    console.log('Drawing circle');",
        "  }",
        "}",
        "",
        "class Rectangle implements Graphic {",
        "  draw() {",
        "    console.log('Drawing rectangle');",
        "  }",
        "}",
        "",
        "// Composite",
        "class CompoundGraphic implements Graphic {",
        "  private children: Graphic[] = [];",
        "  ",
        "  add(child: Graphic) {",
        "    this.children.push(child);",
        "  }",
        "  ",
        "  remove(child: Graphic) {",
        "    const index = this.children.indexOf(child);",
        "    this.children.splice(index, 1);",
        "  }",
        "  ",
        "  draw() {",
        "    console.log('Drawing compound graphic:');",
        "    for (const child of this.children) {",
        "      child.draw();",
        "    }",
        "  }",
        "}",
        "",
        "// Usage",
        "const circle = new Circle();",
        "const rect = new Rectangle();",
        "",
        "const group = new CompoundGraphic();",
        "group.add(circle);",
        "group.add(rect);",
        "",
        "const bigGroup = new CompoundGraphic();",
        "bigGroup.add(group);",
        "bigGroup.add(new Circle());",
        "",
        "bigGroup.draw();",
        "// Drawing compound graphic:",
        "//   Drawing compound graphic:",
        "//     Drawing circle",
        "//     Drawing rectangle",
        "//   Drawing circle",
        "```",
        "",
        "## Use Cases",
        "- File system (files and folders)",
        "- UI component trees (React/Vue)",
        "- Organization hierarchies"
      ],
      "keyPoints": [
        "Tree structure: leaf and composite nodes",
        "Uniform interface for both types",
        "Recursive composition",
        "Common in UI frameworks and file systems"
      ]
    },
    {
      "id": "proxy",
      "title": "Proxy Pattern",
      "description": "Control access to an object",
      "content": [
        "Proxy provides a substitute or placeholder for another object to control access to it.",
        "",
        "## Types of Proxies",
        "",
        "### 1. Virtual Proxy (Lazy Loading)",
        "```typescript",
        "interface Image {",
        "  display(): void;",
        "}",
        "",
        "class RealImage implements Image {",
        "  constructor(private filename: string) {",
        "    this.loadFromDisk();",
        "  }",
        "  ",
        "  private loadFromDisk() {",
        "    console.log(`Loading ${this.filename} from disk...`);",
        "  }",
        "  ",
        "  display() {",
        "    console.log(`Displaying ${this.filename}`);",
        "  }",
        "}",
        "",
        "class ProxyImage implements Image {",
        "  private realImage: RealImage | null = null;",
        "  ",
        "  constructor(private filename: string) {}",
        "  ",
        "  display() {",
        "    if (!this.realImage) {",
        "      this.realImage = new RealImage(this.filename);",
        "    }",
        "    this.realImage.display();",
        "  }",
        "}",
        "",
        "// Usage",
        "const image = new ProxyImage('photo.jpg');",
        "// Image not loaded yet",
        "image.display(); // Now loads and displays",
        "image.display(); // Just displays (already loaded)",
        "```",
        "",
        "### 2. Protection Proxy (Access Control)",
        "```typescript",
        "interface BankAccount {",
        "  withdraw(amount: number): void;",
        "}",
        "",
        "class RealBankAccount implements BankAccount {",
        "  constructor(private balance: number) {}",
        "  ",
        "  withdraw(amount: number) {",
        "    this.balance -= amount;",
        "    console.log(`Withdrew ${amount}, balance: ${this.balance}`);",
        "  }",
        "}",
        "",
        "class BankAccountProxy implements BankAccount {",
        "  constructor(",
        "    private account: RealBankAccount,",
        "    private isAuthorized: boolean",
        "  ) {}",
        "  ",
        "  withdraw(amount: number) {",
        "    if (this.isAuthorized) {",
        "      this.account.withdraw(amount);",
        "    } else {",
        "      console.log('Access denied');",
        "    }",
        "  }",
        "}",
        "```",
        "",
        "## Use Cases",
        "- Lazy loading (virtual proxy)",
        "- Access control (protection proxy)",
        "- Caching (cache proxy)",
        "- Logging, monitoring (logging proxy)"
      ],
      "keyPoints": [
        "Controls access to real object",
        "Same interface as real object",
        "Virtual proxy for lazy loading",
        "Protection proxy for access control"
      ]
    },
    {
      "id": "facade",
      "title": "Facade Pattern",
      "description": "Simplified interface to complex subsystem",
      "content": [
        "Facade provides a simplified interface to a complex subsystem.",
        "",
        "## Problem",
        "Complex library or framework with many classes is hard to use.",
        "",
        "## Solution",
        "```typescript",
        "// Complex subsystem",
        "class CPU {",
        "  freeze() { console.log('CPU: Freezing'); }",
        "  jump(position: number) { console.log(`CPU: Jumping to ${position}`); }",
        "  execute() { console.log('CPU: Executing'); }",
        "}",
        "",
        "class Memory {",
        "  load(position: number, data: string) {",
        "    console.log(`Memory: Loading ${data} at ${position}`);",
        "  }",
        "}",
        "",
        "class HardDrive {",
        "  read(sector: number, size: number): string {",
        "    console.log(`HardDrive: Reading sector ${sector}`);",
        "    return 'boot data';",
        "  }",
        "}",
        "",
        "// Facade",
        "class ComputerFacade {",
        "  private cpu = new CPU();",
        "  private memory = new Memory();",
        "  private hardDrive = new HardDrive();",
        "  ",
        "  start() {",
        "    console.log('Starting computer...');",
        "    this.cpu.freeze();",
        "    const bootData = this.hardDrive.read(0, 1024);",
        "    this.memory.load(0, bootData);",
        "    this.cpu.jump(0);",
        "    this.cpu.execute();",
        "    console.log('Computer started!');",
        "  }",
        "}",
        "",
        "// Usage",
        "const computer = new ComputerFacade();",
        "computer.start(); // Simple interface hides complexity",
        "```",
        "",
        "## Benefits",
        "- Simplifies complex interfaces",
        "- Decouples client from subsystem",
        "- Provides a convenient entry point",
        "",
        "## Use Cases",
        "- Library wrappers (e.g., Axios wrapping fetch)",
        "- Complex system initialization",
        "- Third-party integrations"
      ],
      "keyPoints": [
        "Simplifies complex subsystems",
        "Provides high-level interface",
        "Doesn't prevent access to subsystem",
        "Common in API wrappers and libraries"
      ]
    },
    {
      "id": "command",
      "title": "Command Pattern",
      "description": "Encapsulate requests as objects",
      "content": [
        "Command turns a request into a stand-alone object containing all information about the request.",
        "",
        "## Problem",
        "You want to parameterize objects with operations, queue operations, or support undo.",
        "",
        "## Solution",
        "```typescript",
        "// Command interface",
        "interface Command {",
        "  execute(): void;",
        "  undo(): void;",
        "}",
        "",
        "// Receiver",
        "class Light {",
        "  turnOn() { console.log('Light is ON'); }",
        "  turnOff() { console.log('Light is OFF'); }",
        "}",
        "",
        "// Concrete commands",
        "class TurnOnCommand implements Command {",
        "  constructor(private light: Light) {}",
        "  ",
        "  execute() { this.light.turnOn(); }",
        "  undo() { this.light.turnOff(); }",
        "}",
        "",
        "class TurnOffCommand implements Command {",
        "  constructor(private light: Light) {}",
        "  ",
        "  execute() { this.light.turnOff(); }",
        "  undo() { this.light.turnOn(); }",
        "}",
        "",
        "// Invoker",
        "class RemoteControl {",
        "  private history: Command[] = [];",
        "  ",
        "  executeCommand(command: Command) {",
        "    command.execute();",
        "    this.history.push(command);",
        "  }",
        "  ",
        "  undo() {",
        "    const command = this.history.pop();",
        "    if (command) command.undo();",
        "  }",
        "}",
        "",
        "// Usage",
        "const light = new Light();",
        "const turnOn = new TurnOnCommand(light);",
        "const turnOff = new TurnOffCommand(light);",
        "",
        "const remote = new RemoteControl();",
        "remote.executeCommand(turnOn);  // Light is ON",
        "remote.executeCommand(turnOff); // Light is OFF",
        "remote.undo(); // Light is ON (undo last command)",
        "```",
        "",
        "## Benefits",
        "- Decouples sender from receiver",
        "- Supports undo/redo",
        "- Command queuing and logging",
        "- Macro commands (composite commands)",
        "",
        "## Use Cases",
        "- Undo/Redo functionality",
        "- Task queues",
        "- GUI buttons and menu items",
        "- Transaction systems"
      ],
      "keyPoints": [
        "Encapsulate action as object",
        "Supports undo/redo with history",
        "Decouple sender from receiver",
        "Common in editors and GUI applications"
      ]
    },
    {
      "id": "state",
      "title": "State Pattern",
      "description": "Alter behavior when internal state changes",
      "content": [
        "State allows an object to alter its behavior when its internal state changes.",
        "",
        "## Problem",
        "Object behavior depends on its state, leading to large conditionals.",
        "",
        "❌ **Bad**: State in conditionals",
        "```typescript",
        "class Document {",
        "  state: 'draft' | 'moderation' | 'published';",
        "  ",
        "  publish() {",
        "    if (this.state === 'draft') {",
        "      this.state = 'moderation';",
        "    } else if (this.state === 'moderation') {",
        "      this.state = 'published';",
        "    }",
        "    // Complex conditionals everywhere",
        "  }",
        "}",
        "```",
        "",
        "## Solution: State Pattern",
        "```typescript",
        "interface State {",
        "  publish(doc: Document): void;",
        "  reject(doc: Document): void;",
        "}",
        "",
        "class Document {",
        "  constructor(private state: State) {}",
        "  ",
        "  setState(state: State) {",
        "    this.state = state;",
        "  }",
        "  ",
        "  publish() { this.state.publish(this); }",
        "  reject() { this.state.reject(this); }",
        "}",
        "",
        "class DraftState implements State {",
        "  publish(doc: Document) {",
        "    console.log('Moving to moderation');",
        "    doc.setState(new ModerationState());",
        "  }",
        "  reject(doc: Document) {",
        "    console.log('Already in draft');",
        "  }",
        "}",
        "",
        "class ModerationState implements State {",
        "  publish(doc: Document) {",
        "    console.log('Publishing document');",
        "    doc.setState(new PublishedState());",
        "  }",
        "  reject(doc: Document) {",
        "    console.log('Rejecting, back to draft');",
        "    doc.setState(new DraftState());",
        "  }",
        "}",
        "",
        "class PublishedState implements State {",
        "  publish(doc: Document) {",
        "    console.log('Already published');",
        "  }",
        "  reject(doc: Document) {",
        "    console.log('Cannot reject published doc');",
        "  }",
        "}",
        "",
        "// Usage",
        "const doc = new Document(new DraftState());",
        "doc.publish(); // Moving to moderation",
        "doc.publish(); // Publishing document",
        "```",
        "",
        "## vs Strategy",
        "- **State**: States transition automatically, context usually aware of states",
        "- **Strategy**: Client explicitly chooses strategy"
      ],
      "keyPoints": [
        "Encapsulate state-specific behavior",
        "Eliminates state conditionals",
        "States can transition to other states",
        "Use for complex state machines"
      ]
    },
    {
      "id": "template-method",
      "title": "Template Method Pattern",
      "description": "Define algorithm skeleton, let subclasses override steps",
      "content": [
        "Template Method defines the skeleton of an algorithm but lets subclasses override specific steps.",
        "",
        "## Problem",
        "Multiple classes have similar algorithms with slight variations.",
        "",
        "## Solution",
        "```typescript",
        "abstract class DataMiner {",
        "  // Template method",
        "  mine(path: string): void {",
        "    const file = this.openFile(path);",
        "    const rawData = this.extractData(file);",
        "    const data = this.parseData(rawData);",
        "    const analysis = this.analyzeData(data);",
        "    this.sendReport(analysis);",
        "    this.closeFile(file);",
        "  }",
        "  ",
        "  // Default implementations",
        "  openFile(path: string): any {",
        "    console.log(`Opening file: ${path}`);",
        "    return { path };",
        "  }",
        "  ",
        "  closeFile(file: any): void {",
        "    console.log('Closing file');",
        "  }",
        "  ",
        "  sendReport(analysis: any): void {",
        "    console.log('Sending report:', analysis);",
        "  }",
        "  ",
        "  // Abstract methods - subclasses must implement",
        "  abstract extractData(file: any): string;",
        "  abstract parseData(raw: string): any;",
        "  abstract analyzeData(data: any): any;",
        "}",
        "",
        "class CSVDataMiner extends DataMiner {",
        "  extractData(file: any): string {",
        "    console.log('Extracting CSV data');",
        "    return 'csv,data,here';",
        "  }",
        "  ",
        "  parseData(raw: string): any {",
        "    console.log('Parsing CSV');",
        "    return raw.split(',');",
        "  }",
        "  ",
        "  analyzeData(data: any): any {",
        "    console.log('Analyzing CSV data');",
        "    return { rows: data.length };",
        "  }",
        "}",
        "",
        "class JSONDataMiner extends DataMiner {",
        "  extractData(file: any): string {",
        "    console.log('Extracting JSON data');",
        "    return '{\"key\": \"value\"}';",
        "  }",
        "  ",
        "  parseData(raw: string): any {",
        "    console.log('Parsing JSON');",
        "    return JSON.parse(raw);",
        "  }",
        "  ",
        "  analyzeData(data: any): any {",
        "    console.log('Analyzing JSON data');",
        "    return { keys: Object.keys(data).length };",
        "  }",
        "}",
        "",
        "// Usage",
        "const csvMiner = new CSVDataMiner();",
        "csvMiner.mine('data.csv');",
        "",
        "const jsonMiner = new JSONDataMiner();",
        "jsonMiner.mine('data.json');",
        "```",
        "",
        "## Benefits",
        "- Code reuse (common steps in base class)",
        "- Enforce algorithm structure",
        "- Variations in subclasses",
        "",
        "## Use Cases",
        "- Frameworks (React lifecycle methods)",
        "- Build processes",
        "- Game AI (pathfinding with different heuristics)"
      ],
      "keyPoints": [
        "Define algorithm skeleton in base class",
        "Subclasses override specific steps",
        "Inversion of control (Hollywood Principle)",
        "Common in frameworks and libraries"
      ]
    }
  ]
}